predict(adalars.geo[[i]], newx=scale(as.matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode='step')[['fit']]
predict(adalars.geo[[i]], newx=scale(as.matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode='step')[['fit']] - model.data[colocated,col.out]
colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
     loow = w.unique[i,-colocated]#
     #model = lm(f, data=model.data[-colocated,], weights=loow)#
     w.sqrt <- diag(rep(sqrt(loow), reps))#
     #Compute the adaptive lasso estimates#
     #Generate the adaptive lasso weights#
     x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
     y.weighted = w.sqrt %*% as.matrix(model.data$Y[-colocated])#
     m<-ncol(x.weighted)#
     n<-nrow(x.weighted)#
     one <- rep(1, n)#
     meanx <- drop(one %*% x.weighted)/n#
     x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
     normx <- sqrt(drop(one %*% (x.centered^2)))#
     names(normx) <- NULL#
     xs = x.centered#
     for (k in 1:dim(x.centered)[2]) {#
         if (normx[k]!=0) {#
             xs[,k] = xs[,k] / normx[k]#
         } else {#
             xs[,k] = rep(0, dim(xs)[1])#
             normx[k] = Inf #This should allow the lambda-finding step to work.#
         }#
     }#
     #xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
     out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
     beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
     ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
     for (k in 1:dim(x.centered)[2]) {#
         if (!is.na(ada.weight[k])) {#
             xs[,k] = xs[,k] * ada.weight[k]#
         } else {#
             xs[,k] = rep(0, dim(xs)[1])#
             ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
         }#
     }#
     #Use the lars algorithm to fit the model#
     adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
     l.adalars = c(l.adalars, which.min(colSums(abs(matrix(predict(adalars.geo[[i]], newx=scale(as.matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)[['fit']] - model.data[colocated,col.out], nrow=reps, ncol=length(lambda))))))
l.adalars
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='Y')#
reps = dim(model.data)[1]/n.unique#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
Compute the adaptive lasso estimates#
    #Generate the adaptive lasso weights#
    x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$Y[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    #xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
l.adalars = c(l.adalars, which.min(colSums(abs(predict(adalars.geo[[i]], newx=scale(as.matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode='step')[['fit']] - model.data[colocated,col.out]))))
}
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='logitindpov')#
reps = dim(model.data)[1]/n.unique#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='Y')#
reps = dim(model.data)[1]/n.unique#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
Compute the adaptive lasso estimates#
    #Generate the adaptive lasso weights#
    x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$Y[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    #xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
l.adalars = c(l.adalars, which.min(colSums(abs(matrix(predict(adalars.geo[[i]], newx=scale(as.matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)[['fit']] - model.data[colocated,col.out], nrow=reps, ncol=length(lambda))))))
}
for(row in 1:400) {#
        mat[as.character(df[row,'loc.y']), as.character(df[row,'loc.x'])] = #
            coef.lars(adalars.geo[[row]], mode='lambda', s=l.adalars[row])[["X"]]#
    }
mat
gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='Y')#
reps = dim(model.data)[1]/n.unique#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
Compute the adaptive lasso estimates#
    #Generate the adaptive lasso weights#
    x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$Y[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    #xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
l.adalars = c(l.adalars, which.min(colSums(abs(matrix(predict(adalars.geo[[i]], newx=scale(as.matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)[['fit']] - model.data[colocated,col.out], nrow=reps, ncol=length(lambda)))))/1000)
}
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='Y')#
reps = dim(model.data)[1]/n.unique#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
Generate the adaptive lasso weights#
    x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$Y[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    #xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
l.adalars = c(l.adalars, which.min(colSums(abs(matrix(predict(adalars.geo[[i]], newx=scale(matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)[['fit']] - model.data[colocated,col.out], nrow=reps, ncol=length(lambda)))))/1000)
}
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='Y')#
reps = dim(model.data)[1]/n.unique#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$logitindpov[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    #xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
l.adalars = c(l.adalars, which.min(colSums(abs(matrix(predict(adalars.geo[[i]], newx=scale(matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(model.data)[2]-1), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)[['fit']] - model.data[colocated,col.out], nrow=reps, ncol=length(lambda)))))/1000)
}
predict(adalars.geo[[i]], newx=scale(matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(model.data)[2]-1), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)
i
adalars.geo[[i]]
adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
predict(adalars.geo[[i]], newx=scale(matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(model.data)[2]-1), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)
predict(adalars.geo[[i]], newx=scale(as.matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(model.data)[2]-1), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='Y')#
reps = dim(model.data)[1]/n.unique#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$Y[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    #xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
l.adalars = c(l.adalars, which.min(colSums(abs(matrix(predict(adalars.geo[[i]], newx=scale(as.matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(model.data[,-col.out])[2]), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)[['fit']]) - model.data[colocated,col.out], nrow=reps, ncol=length(lambda)))))/1000)
i
colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$logitindpov[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    #xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
l.adalars = c(l.adalars, which.min(colSums(abs(matrix(predict(adalars.geo[[i]], newx=scale(as.matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(model.data[,-col.out])[2]), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)[['fit']] - model.data[colocated,col.out], nrow=reps, ncol=length(lambda)))))/1000)
l.adalars
colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$Y[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    #xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
l.adalars = c(l.adalars, which.min(colSums(abs(matrix(predict(adalars.geo[[i]], newx=scale(as.matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(model.data[,-col.out])[2]), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)[['fit']] - model.data[colocated,col.out], nrow=reps, ncol=length(lambda)))))/1000)
l.adalars
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='Y')#
reps = dim(model.data)[1]/n.unique#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
Compute the adaptive lasso estimates#
    #Generate the adaptive lasso weights#
    x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$Y[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    #xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
l.adalars = c(l.adalars, which.min(colSums(abs(matrix(predict(adalars.geo[[i]], newx=scale(as.matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(model.data[,-col.out])[2]), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)[['fit']] - model.data[colocated,col.out], nrow=reps, ncol=length(lambda)))))/1000)
}
for(row in 1:400) {#
        mat[as.character(df[row,'loc.y']), as.character(df[row,'loc.x'])] = #
            coef.lars(adalars.geo[[row]], mode='lambda', s=l.adalars[row])[["X"]]#
    }
mat
gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)
length(lambda)
normx/ada.weight
ada.weight
normx
gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='Y')#
reps = dim(model.data)[1]/n.unique#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
Compute the adaptive lasso estimates#
    #Generate the adaptive lasso weights#
    x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$Y[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
}
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='Y')#
reps = dim(model.data)[1]/n.unique#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
Compute the adaptive lasso estimates#
    #Generate the adaptive lasso weights#
    x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$Y[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='Y')#
reps = dim(model.data)[1]/n.unique#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
Compute the adaptive lasso estimates#
    #Generate the adaptive lasso weights#
    x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$Y[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
l.adalars = c(l.adalars, lambda[which.min(colSums(abs(matrix(predict(adalars.geo[[i]], newx=scale(as.matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(model.data[,-col.out])[2]), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)[['fit']] - model.data[colocated,col.out], nrow=reps, ncol=length(lambda)))))])
}
for(row in 1:400) {#
        mat[as.character(df[row,'loc.y']), as.character(df[row,'loc.x'])] = #
            coef.lars(adalars.geo[[row]], mode='lambda', s=l.adalars[row])[["X"]]#
    }
gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)
mat
ada.weight
ada.weight[1]
normx
ada.weight/normx[1]
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='logitindpov')#
reps = dim(model.data)[1]/n.unique#
#
adalars.scale = list()#
adalars.normx = list()#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='Y')#
reps = dim(model.data)[1]/n.unique#
#
adalars.scale = list()#
adalars.normx = list()#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
Generate the adaptive lasso weights#
    x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$Y[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    adalars.normx[[i]] = normx#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    #xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    adalars.scale[[i]] = ada.weight#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
l.adalars = c(l.adalars, lambda[which.min(colSums(abs(matrix(predict(adalars.geo[[i]], newx=scale(as.matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(model.data[,-col.out])[2]), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)[['fit']] - model.data[colocated,col.out], nrow=reps, ncol=length(lambda)))))])
}
}
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='Y')#
reps = dim(model.data)[1]/n.unique#
#
adalars.scale = list()#
adalars.normx = list()#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
Generate the adaptive lasso weights#
    x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$Y[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    adalars.normx[[i]] = normx#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    #xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    adalars.scale[[i]] = ada.weight#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
l.adalars = c(l.adalars, lambda[which.min(colSums(abs(matrix(predict(adalars.geo[[i]], newx=scale(as.matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(model.data[,-col.out])[2]), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)[['fit']] - model.data[colocated,col.out], nrow=reps, ncol=length(lambda)))))])
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='Y')#
reps = dim(model.data)[1]/n.unique#
#
adalars.scale = list()#
adalars.normx = list()#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
Generate the adaptive lasso weights#
    x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$Y[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    adalars.normx[[i]] = normx#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    #xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    adalars.scale[[i]] = ada.weight#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
cv_error = data.frame()#
w.lasso.geo = list()#
glmnet.geo = list()#
lqa.geo = list()#
adalars.geo = list()#
coefs = list()#
ss = seq(0, 1, length.out=100)#
lambda = seq(0, 5, length.out=5000)#
l.lars = vector()#
l.glmnet = vector()#
l.lqa = vector()#
l.adalars = vector()#
col.out = which(names(model.data)=='Y')#
reps = dim(model.data)[1]/n.unique#
#
adalars.scale = list()#
adalars.normx = list()#
for(i in 1:dim(model.coords)[1]) {#
    colocated = which(loc$x==model.coords$x[i] & loc$y==model.coords$y[i])#
    loow = w.unique[i,-colocated]#
#
    #model = lm(f, data=model.data[-colocated,], weights=loow)#
    w.sqrt <- diag(rep(sqrt(loow), reps))
x.weighted = w.sqrt %*% as.matrix(model.data[-colocated,predictors])#
    y.weighted = w.sqrt %*% as.matrix(model.data$Y[-colocated])#
    m<-ncol(x.weighted)#
    n<-nrow(x.weighted)#
    one <- rep(1, n)#
    meanx <- drop(one %*% x.weighted)/n#
    x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
    normx <- sqrt(drop(one %*% (x.centered^2)))#
    adalars.normx[[i]] = normx#
    names(normx) <- NULL#
    xs = x.centered#
    for (k in 1:dim(x.centered)[2]) {#
        if (normx[k]!=0) {#
            xs[,k] = xs[,k] / normx[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            normx[k] = Inf #This should allow the lambda-finding step to work.#
        }#
    }#
#
    #xs <- scale(x.centered, FALSE, normx)        # now rescales with norm (not sd)#
    out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
    beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
    ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
    adalars.scale[[i]] = ada.weight#
    for (k in 1:dim(x.centered)[2]) {#
        if (!is.na(ada.weight[k])) {#
            xs[,k] = xs[,k] * ada.weight[k]#
        } else {#
            xs[,k] = rep(0, dim(xs)[1])#
            ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
        }#
    }#
    #Use the lars algorithm to fit the model#
    adalars.geo[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)
l.adalars = c(l.adalars, lambda[which.min(colSums(abs(matrix(predict(adalars.geo[[i]], newx=scale(as.matrix(model.data[colocated,-col.out], nrow=reps, ncol=dim(model.data[,-col.out])[2]), center=meanx, scale=normx/ada.weight), type='fit', mode='lambda', s=lambda)[['fit']] - model.data[colocated,col.out], nrow=reps, ncol=length(lambda)))))])
}
for(row in 1:400) {#
        mat[as.character(df[row,'loc.y']), as.character(df[row,'loc.x'])] = #
            coef.lars(adalars.geo[[row]], mode='lambda', s=l.adalars[row])[["X"]] * adalars.scale[[row]] / adalars.normx[[row]]#
    }
for(row in 1:400) {#
        mat[as.character(df[row,'loc.y']), as.character(df[row,'loc.x'])] = #
            coef.lars(adalars.geo[[row]], mode='lambda', s=l.adalars[row])[["X"]] * adalars.scale[[row]][1] / adalars.normx[[row]][1]#
    }
for(row in 1:400) {#
        mat[as.character(df[row,'loc.y']), as.character(df[row,'loc.x'])] = #
            coef.lars(adalars.geo[[row]], mode='lambda', s=l.adalars[row])[["X"]] * adalars.scale[[row]][['X']] / adalars.normx[[row]][['X']]#
    }
for(row in 1:400) {#
        mat[as.character(df[row,'loc.y']), as.character(df[row,'loc.x'])] = #
            coef.lars(adalars.geo[[row]], mode='lambda', s=l.adalars[row])[["X"]] * adalars.scale[[row]][1] / adalars.normx[[row]][1]#
    }
gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)
mat
gwr.matplot(mat-B1, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)
gwlars <- function(formula, data, coords, gweight, verbose, longlat, tol, adapt=FALSE, s, method='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
    if (!adapt) {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gwlars.cv.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                RMSE = RMSE, weights = weights, tol = tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    else {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gw.adalars.cv.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                RMSE = RMSE, weights = weights, tol = tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% x, y=w.sqrt %*% y)#
        s.optimal = c(s.optimal, s[which.min(colSums(abs(matrix(predict(model[[i]], newx=as.matrix(x[colocated,]), s=s, type='fit', mode=mode)[['fit']] - matrix(y[colocated]), nrow=reps, ncol=length(s)))))])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        s.optimal = c(s.optimal, s[which.min(colSums(abs(matrix(predict(model[[i]], newx=scale(as.matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']] - matrix(y[colocated]), nrow=reps, ncol=length(s)))))])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
}
gwlars <- function(formula, data, coords, gweight, bw, verbose, longlat, tol, adapt=FALSE, s, mode='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrices of distances and weights#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
    weight.matrix = gweight(D, bw)#
#
    if (!adapt) {#
        res = gwlars.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    else {#
        res = gwlars.adaptive.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% x, y=w.sqrt %*% y)#
        s.optimal = c(s.optimal, s[which.min(colSums(abs(matrix(predict(model[[i]], newx=as.matrix(x[colocated,]), s=s, type='fit', mode=mode)[['fit']] - matrix(y[colocated]), nrow=reps, ncol=length(s)))))])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        s.optimal = c(s.optimal, s[which.min(colSums(abs(matrix(predict(model[[i]], newx=scale(as.matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']] - matrix(y[colocated]), nrow=reps, ncol=length(s)))))])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
}
gwlars(Y~X+Z, data=sim, coords=loc, gweight=bisquare, bw=bw, verbose=TRUE, longlat=FALSE, adapt=FALSE, s=seq(0,5,length.out=5000))
names(sim)
names(model.data)
gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=TRUE, longlat=FALSE, adapt=FALSE, s=seq(0,5,length.out=5000))
gwlars <- function(formula, data, coords, gweight, bw, verbose, longlat, tol, adapt=FALSE, s, mode='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrices of distances and weights#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
    weight.matrix = gweight(D, bw)#
#
    if (!adapt) {#
        res = gwlars.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    else {#
        res = gwlars.adaptive.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated])))#
        s.optimal = c(s.optimal, s[which.min(colSums(abs(matrix(predict(model[[i]], newx=as.matrix(x[colocated,]), s=s, type='fit', mode=mode)[['fit']] - matrix(y[colocated]), nrow=reps, ncol=length(s)))))])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        s.optimal = c(s.optimal, s[which.min(colSums(abs(matrix(predict(model[[i]], newx=scale(as.matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']] - matrix(y[colocated]), nrow=reps, ncol=length(s)))))])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
}
gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=TRUE, longlat=FALSE, adapt=FALSE, s=seq(0,5,length.out=5000))
gwlars <- function(formula, data, coords, gweight, bw, verbose, longlat, tol, adapt=FALSE, s, mode='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrices of distances and weights#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
    weight.matrix = gweight(D, bw)#
#
    if (!adapt) {#
        res = gwlars.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    else {#
        res = gwlars.adaptive.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    print("entering gwlars.fit")#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated])))#
        s.optimal = c(s.optimal, s[which.min(colSums(abs(matrix(predict(model[[i]], newx=as.matrix(x[colocated,]), s=s, type='fit', mode=mode)[['fit']] - matrix(y[colocated]), nrow=reps, ncol=length(s)))))])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        s.optimal = c(s.optimal, s[which.min(colSums(abs(matrix(predict(model[[i]], newx=scale(as.matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']] - matrix(y[colocated]), nrow=reps, ncol=length(s)))))])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
}
gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=TRUE, longlat=FALSE, adapt=FALSE, s=seq(0,5,length.out=5000))
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    print("entering gwlars.fit")#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        s.optimal = c(s.optimal, s[which.min(colSums(abs(matrix(predict(model[[i]], newx=as.matrix(x[colocated,]), s=s, type='fit', mode=mode)[['fit']] - matrix(y[colocated]), nrow=reps, ncol=length(s)))))])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
}
gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=TRUE, longlat=FALSE, adapt=FALSE, s=seq(0,5,length.out=5000))
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        print("Made model")#
        s.optimal = c(s.optimal, s[which.min(colSums(abs(matrix(predict(model[[i]], newx=as.matrix(x[colocated,]), s=s, type='fit', mode=mode)[['fit']] - matrix(y[colocated]), nrow=reps, ncol=length(s)))))])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
}
gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=TRUE, longlat=FALSE, adapt=FALSE, s=seq(0,5,length.out=5000))
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=as.matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        s.optimal = c(s.optimal, s[which.min(colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s)))))])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
}
gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=TRUE, longlat=FALSE, adapt=FALSE, s=seq(0,5,length.out=5000))
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=as.matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        print("Made predictions")#
        s.optimal = c(s.optimal, s[which.min(colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s)))))])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
}
gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=TRUE, longlat=FALSE, adapt=FALSE, s=seq(0,5,length.out=5000))
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        print("Made predictions")#
        s.optimal = c(s.optimal, s[which.min(colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s)))))])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
}
gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=TRUE, longlat=FALSE, adapt=FALSE, s=seq(0,5,length.out=5000))
gwlars <- function(formula, data, coords, gweight, bw, verbose, longlat, tol, adapt=FALSE, s, mode='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrices of distances and weights#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
    weight.matrix = gweight(D, bw)#
#
    if (!adapt) {#
        res = gwlars.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    else {#
        res = gwlars.adaptive.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwlars.object = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        s.optimal = c(s.optimal, s[which.min(colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s)))))])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    return(gwlars.object)#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        s.optimal = c(s.optimal, s[which.min(colSums(abs(matrix(predict(model[[i]], newx=scale(as.matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']] - matrix(y[colocated]), nrow=reps, ncol=length(s)))))])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    return(gwlars.object)#
}
gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=FALSE, longlat=FALSE, adapt=FALSE, s=seq(0,5,length.out=5000))
model = gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=FALSE, longlat=FALSE, adapt=FALSE, s=seq(0,5,length.out=5000))
class(model)
class(model) = 'gwlars.object'
class(model)
gwlars <- function(formula, data, coords, gweight, bw, verbose, longlat, tol, adapt=FALSE, s, mode='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrices of distances and weights#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
    weight.matrix = gweight(D, bw)#
#
    if (!adapt) {#
        res = gwlars.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    else {#
        res = gwlars.adaptive.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwlars.object = list()#
    cv.error = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s)))#
        s.optimal = c(s.optimal, s[which.min(cv.error))])#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    cv.error = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        predictions = predict(model[[i]], newx=scale(as.matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error)])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}
model = gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=FALSE, longlat=FALSE, adapt=FALSE, s=seq(0,5,length.out=5000))
bw
model
str(model)
model = gwlars(?sapply)
?sapply
sapply(model[['cv.error']], min)
model[['cv.error']]
model[['s']]
gwlars <- function(formula, data, coords, gweight, bw, verbose, longlat, tol, adapt=FALSE, s, mode='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrices of distances and weights#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
    weight.matrix = gweight(D, bw)#
#
    if (!adapt) {#
        res = gwlars.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    else {#
        res = gwlars.adaptive.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwlars.object = list()#
    cv.error = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s)))#
        s.optimal = c(s.optimal, s[which.min(cv.error))])#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose=FALSE) {#
#Fit the GWLARS model (adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    cv.error = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        predictions = predict(model[[i]], newx=scale(as.matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error)])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}
model = gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=FALSE, longlat=FALSE, adapt=FALSE, s=seq(0,5,length.out=5000))
model[['cv.error']]
model[['s']]
class(model)
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwlars.object = list()#
    cv.error = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s)))#
        s.optimal = c(s.optimal, s[which.min(cv.error))])#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}
gwlars <- function(formula, data, coords, gweight, bw, verbose=FALSE, longlat, tol, adapt=FALSE, s, mode='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrices of distances and weights#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
    weight.matrix = gweight(D, bw)#
#
    if (!adapt) {#
        res = gwlars.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    else {#
        res = gwlars.adaptive.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwlars.object = list()#
    cv.error = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error)])#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    cv.error = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        predictions = predict(model[[i]], newx=scale(as.matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error)])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}
model = gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=FALSE, longlat=FALSE, adapt=FALSE, s=seq(0,5,length.out=5000))
gwlars <- function(formula, data, coords, gweight, bw, verbose=FALSE, longlat, tol, adapt=FALSE, s, mode='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrices of distances and weights#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
    weight.matrix = gweight(D, bw)#
#
    if (!adapt) {#
        res = gwlars.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    else {#
        res = gwlars.adaptive.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwlars.object = list()#
    cv.error = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    cv.error = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        predictions = predict(model[[i]], newx=scale(as.matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}
model = gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=FALSE, longlat=FALSE, adapt=FALSE, s=seq(0,5,length.out=5000))
sum(sapply(model[['cv.error']], min))
library(fossil)#
#
gwlars.sel = function(formula, data=list(), coords, adapt=FALSE, gweight=gwr.Gauss, method="cv", verbose=TRUE, longlat=NULL, RMSE=FALSE, weights, tol=.Machine$double.eps^0.25) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
    if (!adapt) {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gwlars.cv.f, lower = beta1, upper = beta2, #
                maximum = FALSE, formula=formula, coords = coords, s = s, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                RMSE = RMSE, weights = weights, tol = tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    else {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gw.adalars.cv.f, lower = beta1, upper = beta2, #
                maximum = FALSE, formula=formula, coords = coords, s = s, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                RMSE = RMSE, weights = weights, tol = tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    res#
}#
gwlars.cv.f = function(formula, bw, coords, gweight, verbose, longlat, tol, ...) {    #
    #Generate the model with the given bandwidth:#
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=FALSE, longlat=longlat, adapt=FALSE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', cv.error, '\n', sep=''))#
    return(cv.error)#
}#
gw.adalars.cv.f = function(bw, y, x, coords, gweight, verbose, longlat, tol, ...) {    #
    ##
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=FALSE, longlat=longlat, adapt=TRUE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', error.cv, '\n', sep=''))#
    return(error.cv)#
}
model = gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
gwlars <- function(formula, data, coords, gweight, bw, verbose=FALSE, longlat, tol, adapt=FALSE, s, mode='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrices of distances and weights#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
    weight.matrix = gweight(D, bw)#
#
    if (!adapt) {#
        res = gwlars.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    else {#
        res = gwlars.adaptive.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwlars.object = list()#
    cv.error = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    cv.error = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}
model = gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
gwlars <- function(formula, data, coords, gweight, bw, verbose=FALSE, longlat, tol, adapt=FALSE, s, mode='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrices of distances and weights#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
    weight.matrix = gweight(D, bw)#
#
    if (!adapt) {#
        res = gwlars.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    else {#
        res = gwlars.adaptive.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwlars.object = list()#
    cv.error = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (adaptive algorithm)#
    gwlars.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    cv.error = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}
model = gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
sapply(model[['cv.error']], min)
sum(sapply(model[['cv.error']], min))
library(fossil)#
#
gwlars.sel = function(formula, data=list(), coords, adapt=FALSE, gweight=gwr.Gauss, method="cv", verbose=TRUE, longlat=NULL, RMSE=FALSE, weights, tol=.Machine$double.eps^0.25) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
    if (!adapt) {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gwlars.cv.f, lower = beta1, upper = beta2, #
                maximum = FALSE, formula=formula, coords = coords, s = s, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                RMSE = RMSE, weights = weights, tol = tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    else {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gw.adalars.cv.f, lower = beta1, upper = beta2, #
                maximum = FALSE, formula=formula, coords = coords, s = s, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                RMSE = RMSE, weights = weights, tol = tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    res#
}#
gwlars.cv.f = function(formula, bw, coords, gweight, verbose, longlat, tol, ...) {    #
    #Generate the model with the given bandwidth:#
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=FALSE, longlat=longlat, adapt=FALSE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', cv.error, '\n', sep=''))#
    return(cv.error)#
}#
gw.adalars.cv.f = function(bw, y, x, coords, gweight, verbose, longlat, tol, ...) {    #
    ##
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=FALSE, longlat=longlat, adapt=TRUE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', error.cv, '\n', sep=''))#
    return(error.cv)#
}
model = gwlars.sel(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
library(fossil)#
#
gwlars.sel = function(formula, data=list(), coords, adapt=FALSE, gweight=gwr.Gauss, mode, s, method="cv", verbose=FALSE, longlat=FALSE, RMSE=FALSE, weights, tol=.Machine$double.eps^0.25) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
    if (!adapt) {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gwlars.cv.f, lower = beta1, upper = beta2, #
                maximum = FALSE, formula=formula, coords = coords, s = s, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                RMSE = RMSE, weights = weights, tol = tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    else {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gw.adalars.cv.f, lower = beta1, upper = beta2, #
                maximum = FALSE, formula=formula, coords = coords, s = s, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                RMSE = RMSE, weights = weights, tol = tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    res#
}#
gwlars.cv.f = function(formula, bw, coords, gweight, verbose, longlat, tol, ...) {    #
    #Generate the model with the given bandwidth:#
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=FALSE, longlat=longlat, adapt=FALSE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', cv.error, '\n', sep=''))#
    return(cv.error)#
}#
gw.adalars.cv.f = function(bw, y, x, coords, gweight, verbose, longlat, tol, ...) {    #
    ##
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=FALSE, longlat=longlat, adapt=TRUE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', error.cv, '\n', sep=''))#
    return(error.cv)#
}
model = gwlars.sel(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
loc
library(fossil)#
#
gwlars.sel = function(formula, data=list(), coords, adapt=FALSE, gweight=gwr.Gauss, mode, s, method="cv", verbose=FALSE, longlat=FALSE, RMSE=FALSE, weights, tol=.Machine$double.eps^0.25) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
    if (!adapt) {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gwlars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    else {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gw.adalars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    res#
}#
gwlars.cv.f = function(formula, bw, coords, gweight, verbose, longlat, tol, ...) {    #
    #Generate the model with the given bandwidth:#
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=FALSE, longlat=longlat, adapt=FALSE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', cv.error, '\n', sep=''))#
    return(cv.error)#
}#
gw.adalars.cv.f = function(bw, y, x, coords, gweight, verbose, longlat, tol, ...) {    #
    ##
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=FALSE, longlat=longlat, adapt=TRUE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', error.cv, '\n', sep=''))#
    return(error.cv)#
}
model = gwlars.sel(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
model = gwlars.sel(Y~X+Z, data=model.data, gweight=bisquare, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
model = gwlars.sel(Y~X+Z, data=model.data, gweight=bisquare, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000), weights=-1)
model = gwlars.sel(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000), weights=-1)
model = gwlars.sel(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000), weights=rep(-1,400))
library(fossil)#
#
gwlars.sel = function(formula, data=list(), coords, adapt=FALSE, gweight=gwr.Gauss, mode, s, method="cv", verbose=FALSE, longlat=FALSE, RMSE=FALSE, weights, tol=.Machine$double.eps^0.25) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
    if (!adapt) {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gwlars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    else {#
        print("adapt")#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gw.adalars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    res#
}#
gwlars.cv.f = function(formula, bw, coords, gweight, verbose, longlat, tol, ...) {    #
    #Generate the model with the given bandwidth:#
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=FALSE, longlat=longlat, adapt=FALSE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', cv.error, '\n', sep=''))#
    return(cv.error)#
}#
gw.adalars.cv.f = function(bw, y, x, coords, gweight, verbose, longlat, tol, ...) {    #
    ##
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=FALSE, longlat=longlat, adapt=TRUE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', error.cv, '\n', sep=''))#
    return(error.cv)#
}
model = gwlars.sel(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
library(fossil)#
#
gwlars.sel = function(formula, data=list(), coords, adapt=FALSE, gweight=gwr.Gauss, mode, s, method="cv", verbose=FALSE, longlat=FALSE, RMSE=FALSE, weights, tol=.Machine$double.eps^0.25) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
    if (!adapt) {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gwlars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    else {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            print("going out to optimize")#
            opt <- optimize(gw.adalars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    res#
}#
gwlars.cv.f = function(formula, bw, coords, gweight, verbose, longlat, tol, ...) {    #
    #Generate the model with the given bandwidth:#
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=FALSE, longlat=longlat, adapt=FALSE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', cv.error, '\n', sep=''))#
    return(cv.error)#
}#
gw.adalars.cv.f = function(bw, y, x, coords, gweight, verbose, longlat, tol, ...) {    #
    ##
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=FALSE, longlat=longlat, adapt=TRUE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', error.cv, '\n', sep=''))#
    return(error.cv)#
}
model = gwlars.sel(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
library(fossil)#
#
gwlars.sel = function(formula, data=list(), coords, adapt=FALSE, gweight=gwr.Gauss, mode, s, method="cv", verbose=FALSE, longlat=FALSE, RMSE=FALSE, weights, tol=.Machine$double.eps^0.25) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
    if (!adapt) {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gwlars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    else {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gw.adalars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    res#
}#
gwlars.cv.f = function(formula, bw, coords, gweight, verbose, longlat, tol, ...) {    #
    #Generate the model with the given bandwidth:#
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=FALSE, longlat=longlat, adapt=FALSE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', cv.error, '\n', sep=''))#
    return(cv.error)#
}#
gw.adalars.cv.f = function(bw, y, x, coords, gweight, verbose, longlat, tol, ...) {    #
    ##
    print("in gw.adalars.cv.f")#
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=FALSE, longlat=longlat, adapt=TRUE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', error.cv, '\n', sep=''))#
    return(error.cv)#
}
model = gwlars.sel(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
library(fossil)#
#
gwlars.sel = function(formula, data=list(), coords, adapt=FALSE, gweight=gwr.Gauss, mode, s, method="cv", verbose=FALSE, longlat=FALSE, RMSE=FALSE, weights, tol=.Machine$double.eps^0.25) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
    if (!adapt) {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gwlars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, data=data, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    else {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gw.adalars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, data=data, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    res#
}#
gwlars.cv.f = function(formula, data=data, bw=bw, coords, gweight, verbose, adapt, longlat, tol, ...) {    #
    #Generate the model with the given bandwidth:#
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=verbose, longlat=longlat, adapt=adapt, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', cv.error, '\n', sep=''))#
    return(cv.error)#
}#
gw.adalars.cv.f = function(bw, y, x, coords, gweight, verbose, longlat, tol, ...) {    #
    ##
    gwlars.model = gwlars(formula=formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=verbose, longlat=longlat, adapt=TRUE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', error.cv, '\n', sep=''))#
    return(error.cv)#
}
library(fossil)#
#
gwlars.sel = function(formula, data=list(), coords, adapt=FALSE, gweight=gwr.Gauss, mode, s, method="cv", verbose=FALSE, longlat=FALSE, RMSE=FALSE, weights, tol=.Machine$double.eps^0.25) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
    if (!adapt) {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gwlars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, data=data, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    else {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gw.adalars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, data=data, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    res#
}#
gwlars.cv.f = function(formula, data=data, bw=bw, coords, gweight, verbose, adapt, longlat, tol, ...) {    #
    #Generate the model with the given bandwidth:#
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=verbose, longlat=longlat, adapt=adapt, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', cv.error, '\n', sep=''))#
    return(cv.error)#
}#
gw.adalars.cv.f = function(formula, data=data, bw=bw, coords, gweight, verbose, adapt, longlat, tol, ...) {    #
    ##
    gwlars.model = gwlars(formula=formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=verbose, longlat=longlat, adapt=TRUE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', error.cv, '\n', sep=''))#
    return(error.cv)#
}
model = gwlars.sel(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
library(fossil)#
#
gwlars.sel = function(formula, data=list(), coords, adapt=FALSE, gweight=gwr.Gauss, mode, s, method="cv", verbose=FALSE, longlat=FALSE, RMSE=FALSE, weights, tol=.Machine$double.eps^0.25) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
    if (!adapt) {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gwlars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, data=data, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    else {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gw.adalars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, data=data, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    res#
}#
gwlars.cv.f = function(formula, data, bw, coords, gweight, verbose, adapt, longlat, mode, s, tol, ...) {    #
    #Generate the model with the given bandwidth:#
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=verbose, longlat=longlat, adapt=adapt, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', cv.error, '\n', sep=''))#
    return(cv.error)#
}#
gw.adalars.cv.f = function(formula, data, bw, coords, gweight, verbose, adapt, longlat, mode, s, tol, ...) {    #
    ##
    gwlars.model = gwlars(formula=formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=verbose, longlat=longlat, adapt=TRUE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', error.cv, '\n', sep=''))#
    return(error.cv)#
}
model = gwlars.sel(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
library(fossil)#
#
gwlars.sel = function(formula, data=list(), coords, adapt=FALSE, gweight=gwr.Gauss, mode, s, method="cv", verbose=FALSE, longlat=FALSE, RMSE=FALSE, weights, tol=.Machine$double.eps^0.25) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
    if (!adapt) {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gwlars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, data=data, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    else {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gw.adalars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, data=data, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    res#
}#
gwlars.cv.f = function(formula, data, bw, coords, gweight, verbose, adapt, longlat, mode, s, tol, ...) {    #
    #Generate the model with the given bandwidth:#
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=verbose, longlat=longlat, adapt=adapt, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', cv.error, '\n', sep=''))#
    return(cv.error)#
}#
gw.adalars.cv.f = function(formula, data, bw, coords, gweight, verbose, adapt, longlat, mode, s, tol, ...) {    #
    ##
    gwlars.model = gwlars(formula=formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=verbose, longlat=longlat, adapt=TRUE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', error.cv, '\n', sep=''))#
    return(cv.error)#
}
library(fossil)#
#
gwlars.sel = function(formula, data=list(), coords, adapt=FALSE, gweight=gwr.Gauss, mode, s, method="cv", verbose=FALSE, longlat=FALSE, RMSE=FALSE, weights, tol=.Machine$double.eps^0.25) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
    if (!adapt) {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gwlars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, data=data, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    else {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- difmin#
        if (method == "cv") {#
            opt <- optimize(gw.adalars.cv.f, lower=beta1, upper=beta2, #
                maximum=FALSE, formula=formula, coords=coords, s=s, mode=mode,#
                gweight=gweight, verbose=verbose, longlat=longlat, data=data, #
                RMSE=RMSE, weights=weights, tol=tol)#
        }#
        else {#
            opt <- optimize(gwr.aic.f, lower = beta1, upper = beta2, #
                maximum = FALSE, y = y, x = x, coords = coords, #
                gweight = gweight, verbose = verbose, longlat = longlat, #
                tol = tol)#
        }#
        bdwt <- opt$minimum#
        res <- bdwt#
    }#
    res#
}#
gwlars.cv.f = function(formula, data, bw, coords, gweight, verbose, adapt, longlat, mode, s, tol, ...) {    #
    #Generate the model with the given bandwidth:#
    gwlars.model = gwlars(formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=verbose, longlat=longlat, adapt=adapt, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', cv.error, '\n', sep=''))#
    return(cv.error)#
}#
gw.adalars.cv.f = function(formula, data, bw, coords, gweight, verbose, adapt, longlat, mode, s, tol, ...) {    #
    ##
    gwlars.model = gwlars(formula=formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=verbose, longlat=longlat, adapt=TRUE, s=s)#
    cv.error = sum(sapply(gwlars.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', cv.error, '\n', sep=''))#
    return(cv.error)#
}
model = gwlars.sel(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
gwlars <- function(formula, data, coords, gweight, bw, verbose=FALSE, longlat, tol, adapt=FALSE, s, mode='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrices of distances and weights#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
    weight.matrix = gweight(D, bw)#
#
    if (!adapt) {#
        res = gwlars.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    else {#
        res = gwlars.adaptive.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwlars.object = list()#
    cv.error = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (adaptive algorithm)#
    gwlars.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    cv.error = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }            #
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}
model = gwlars.sel(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
model
bw=model
model = gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
plot.coef.gwlars(model=model, var="X", locs=loc, data=model.data, s=seq(0,5,length.out=5000))
gwr.heatmap <- function(model, variable) { #
    #Prepare something for plotting:#
    name.var = var#
    var = vector()#
    for (i in 1:length(model)) {#
        var = c(var, coef.lars(model[['model']][[i]], mode=model[['mode']], s=model[['s']][i])[[name.var]])#
    }#
    df.plot = data.frame(output=var)#
    #Isolate the variable to plot:#
    locations = model[['coords']]#
    coef.surface = as.data.frame(cbind(locations, var))#
    names(coef.surface)[3] = variable#
    #Heatmap of the data#
    locations = list(lat=unique(locations[,2]), long=unique(locations[,1]))#
    mat = matrix(NA, nrow=length(locations[['lat']]), ncol=length(locations[['long']]))#
    rownames(mat) <- sort(unique(coef.surface[,2]), decreasing=F)#
    colnames(mat) <- sort(unique(coef.surface[,1]), decreasing=F)         #
    #Put the coefficients into a lat-long matrix#
    for(row in 1:dim(coef.surface)[1]) {#
        mat[as.character(coef.surface[row,2]), as.character(coef.surface[row,1])] = #
            ifelse(!is.na(coef.surface[row,variable]), coef.surface[row,variable], NA)#
    }#
#
    #par(bty='n')#
    gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)#
}
gwr.heatmap(model, "X")
model[['model']]
gwr.heatmap(model, "X")
model[['mode']]
model[['s']]
i
model[['s']][i]
coef.lars(model[["model"]][[i]], mode = model[["mode"]], s = model[["s"]][i])
name.var
gwr.heatmap <- function(model, variable) { #
    #Prepare something for plotting:#
    name.var = variable#
    var = vector()#
    for (i in 1:length(model)) {#
        var = c(var, coef.lars(model[['model']][[i]], mode=model[['mode']], s=model[['s']][i])[[name.var]])#
    }#
    df.plot = data.frame(output=var)#
    #Isolate the variable to plot:#
    locations = model[['coords']]#
    coef.surface = as.data.frame(cbind(locations, var))#
    names(coef.surface)[3] = variable#
    #Heatmap of the data#
    locations = list(lat=unique(locations[,2]), long=unique(locations[,1]))#
    mat = matrix(NA, nrow=length(locations[['lat']]), ncol=length(locations[['long']]))#
    rownames(mat) <- sort(unique(coef.surface[,2]), decreasing=F)#
    colnames(mat) <- sort(unique(coef.surface[,1]), decreasing=F)         #
    #Put the coefficients into a lat-long matrix#
    for(row in 1:dim(coef.surface)[1]) {#
        mat[as.character(coef.surface[row,2]), as.character(coef.surface[row,1])] = #
            ifelse(!is.na(coef.surface[row,variable]), coef.surface[row,variable], NA)#
    }#
#
    #par(bty='n')#
    gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)#
}
coef.lars(model[["model"]][[i]], mode = model[["mode"]], s = model[["s"]][i])
gwr.heatmap(model, "X")
name.var
name.var='X'
Prepare something for plotting:#
    name.var = variable#
    var = vector()#
    for (i in 1:length(model)) {#
        var = c(var, coef.lars(model[['model']][[i]], mode=model[['mode']], s=model[['s']][i])[[name.var]])#
    }#
    df.plot = data.frame(output=var)#
    #Isolate the variable to plot:#
    locations = model[['coords']]#
    coef.surface = as.data.frame(cbind(locations, var))#
    names(coef.surface)[3] = name.var#
    #Heatmap of the data#
    locations = list(lat=unique(locations[,2]), long=unique(locations[,1]))#
    mat = matrix(NA, nrow=length(locations[['lat']]), ncol=length(locations[['long']]))#
    rownames(mat) <- sort(unique(coef.surface[,2]), decreasing=F)#
    colnames(mat) <- sort(unique(coef.surface[,1]), decreasing=F)         #
    #Put the coefficients into a lat-long matrix#
    for(row in 1:dim(coef.surface)[1]) {#
        mat[as.character(coef.surface[row,2]), as.character(coef.surface[row,1])] = #
            ifelse(!is.na(coef.surface[row,name.var]), coef.surface[row,name.var], NA)#
    }#
#
    #par(bty='n')#
    gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)
variable='X'
Prepare something for plotting:#
    name.var = variable#
    var = vector()#
    for (i in 1:length(model)) {#
        var = c(var, coef.lars(model[['model']][[i]], mode=model[['mode']], s=model[['s']][i])[[name.var]])#
    }#
    df.plot = data.frame(output=var)#
    #Isolate the variable to plot:#
    locations = model[['coords']]#
    coef.surface = as.data.frame(cbind(locations, var))#
    names(coef.surface)[3] = name.var#
    #Heatmap of the data#
    locations = list(lat=unique(locations[,2]), long=unique(locations[,1]))#
    mat = matrix(NA, nrow=length(locations[['lat']]), ncol=length(locations[['long']]))#
    rownames(mat) <- sort(unique(coef.surface[,2]), decreasing=F)#
    colnames(mat) <- sort(unique(coef.surface[,1]), decreasing=F)         #
    #Put the coefficients into a lat-long matrix#
    for(row in 1:dim(coef.surface)[1]) {#
        mat[as.character(coef.surface[row,2]), as.character(coef.surface[row,1])] = #
            ifelse(!is.na(coef.surface[row,name.var]), coef.surface[row,name.var], NA)#
    }#
#
    #par(bty='n')#
    gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)
names(df.plot)
names(coef.surface)
dim(coef.surface)
coef.lars(model[['model']][[i]], mode=model[['mode']], s=model[['s']][i])
i
i=300
i
coef.lars(model[['model']][[i]], mode=model[['mode']], s=model[['s']][i])
gwlars <- function(formula, data, coords, gweight, bw, verbose=FALSE, longlat, tol, adapt=FALSE, s, mode='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrices of distances and weights#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
    weight.matrix = gweight(D, bw)#
#
    if (!adapt) {#
        res = gwlars.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    else {#
        res = gwlars.adaptive.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwlars.object = list()#
    cv.error = list()#
    coef.scale = vector()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        coef.scale = c(coef.scale, 1)#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['coef.scale']] = coef.scale#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (adaptive algorithm)#
    gwlars.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    cv.error = list()#
    coef.scale = vector()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }            #
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        coef.scale = c(coef.scale, ada.weight/normx)#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['coef.scale']] = coef.scale#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}
model = gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
gwr.heatmap <- function(model, variable) { #
    #Prepare something for plotting:#
    name.var = variable#
    var = vector()#
    for (i in 1:length(model)) {#
        var = c(var, model[['coef.scale']][i] * coef.lars(model[['model']][[i]], mode=model[['mode']], s=model[['s']][i])[[name.var]])#
    }#
    df.plot = data.frame(output=var)#
    #Isolate the variable to plot:#
    locations = model[['coords']]#
    coef.surface = as.data.frame(cbind(locations, var))#
    names(coef.surface)[3] = name.var#
    #Heatmap of the data#
    locations = list(lat=unique(locations[,2]), long=unique(locations[,1]))#
    mat = matrix(NA, nrow=length(locations[['lat']]), ncol=length(locations[['long']]))#
    rownames(mat) <- sort(unique(coef.surface[,2]), decreasing=F)#
    colnames(mat) <- sort(unique(coef.surface[,1]), decreasing=F)         #
    #Put the coefficients into a lat-long matrix#
    for(row in 1:dim(coef.surface)[1]) {#
        mat[as.character(coef.surface[row,2]), as.character(coef.surface[row,1])] = #
            ifelse(!is.na(coef.surface[row,name.var]), coef.surface[row,name.var], NA)#
    }#
#
    #par(bty='n')#
    gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)#
}
gwr.heatmap(model, 'X')
model[['coef.scale']]
model[['coef.scale']]
?split
?strSplit
?strsplit
strsplit(model[['coef.scale']], 'xs')
strsplit(names(model[['coef.scale']]), 'xs')
strsplit(names(model[['coef.scale']][[1]]), 'xs')
gwlars <- function(formula, data, coords, gweight, bw, verbose=FALSE, longlat, tol, adapt=FALSE, s, mode='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrices of distances and weights#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
    weight.matrix = gweight(D, bw)#
#
    if (!adapt) {#
        res = gwlars.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    else {#
        res = gwlars.adaptive.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwlars.object = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        coef.scale[[i]] = 1#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['coef.scale']] = coef.scale#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (adaptive algorithm)#
    gwlars.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }            #
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        coef.scale[[i]] = ada.weight/normx#
        #names(coef.scale[[i]]) = strsplit(names(coef.scale[[i]]), 'xs')#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['coef.scale']] = coef.scale#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}
model = gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
strsplit(names(model[['coef.scale']][[1]]), 'xs')
strsplit(names(model[['coef.scale']][[1]]), 'xs')[2]
strsplit(names(model[['coef.scale']][[1]]), 'xs')[,2]
sapply(strsplit(names(model[['coef.scale']][[1]]), 'xs'), function(x) {x[2]})
gwlars <- function(formula, data, coords, gweight, bw, verbose=FALSE, longlat, tol, adapt=FALSE, s, mode='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrices of distances and weights#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
    weight.matrix = gweight(D, bw)#
#
    if (!adapt) {#
        res = gwlars.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    else {#
        res = gwlars.adaptive.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwlars.object = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        coef.scale[[i]] = rep(1, dim(x)[2])#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['coef.scale']] = coef.scale#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (adaptive algorithm)#
    gwlars.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }            #
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        coef.scale[[i]] = ada.weight/normx#
        names(coef.scale[[i]]) = sapply(strsplit(names(model[['coef.scale']][[i]]), 'xs'), function(x) {x[2]})#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['coef.scale']] = coef.scale#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}
model = gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
gwlars <- function(formula, data, coords, gweight, bw, verbose=FALSE, longlat, tol, adapt=FALSE, s, mode='lambda') {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrices of distances and weights#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
    weight.matrix = gweight(D, bw)#
#
    if (!adapt) {#
        res = gwlars.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    else {#
        res = gwlars.adaptive.fit(x, y, coords, weight.matrix, s, mode, verbose)#
    }#
    res#
}#
gwlars.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwlars.object = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        coef.scale[[i]] = rep(1, dim(x)[2])#
        model[[i]] = lars(x=w.sqrt %*% as.matrix(x[-colocated,]), y=w.sqrt %*% as.matrix(y[-colocated]))#
        predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), s=s, type='fit', mode=mode)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - as.matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['coef.scale']] = coef.scale#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}#
gwlars.adaptive.fit = function(x, y, coords, weight.matrix, s, mode, verbose) {#
#Fit the GWLARS model (adaptive algorithm)#
    gwlars.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adalars.normx = list()#
    adalars.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords$x==coords.unique$x[i] & coords$y==coords.unique$y[i])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }            #
        reps = length(colocated)        #
        w.sqrt <- diag(rep(sqrt(loow), reps))#
        x.weighted = w.sqrt %*% x[-colocated,]#
        y.weighted = w.sqrt %*% as.matrix(y[-colocated])#
        m <- ncol(x.weighted)#
        n <- nrow(x.weighted)#
        one <- rep(1, n)#
        meanx <- drop(one %*% x.weighted)/n#
        x.centered <- scale(x.weighted, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adalars.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.ls = lm(y.weighted~xs)                      # ols fit on standardized#
        beta.ols = out.ls$coeff[2:(m+1)]       # ols except for intercept#
        ada.weight = abs(beta.ols)                      # weights for adaptive lasso#
        adalars.scale[[i]] = ada.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(ada.weight[k])) {#
                xs[,k] = xs[,k] * ada.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                ada.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        coef.scale[[i]] = ada.weight/normx#
        names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
        model[[i]] = lars(x=xs, y=y.weighted, normalize=FALSE)#
        predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(x)[2]), center=meanx, scale=normx/ada.weight), type='fit', mode=mode, s=s)[['fit']]#
        cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated]), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwlars.object[['coef.scale']] = coef.scale#
    gwlars.object[['model']] = model#
    gwlars.object[['s']] = s.optimal#
    gwlars.object[['mode']] = mode#
    gwlars.object[['coords']] = coords#
    gwlars.object[['cv.error']] = cv.error#
    class(gwlars.object) = 'gwlars.object'#
    return(gwlars.object)#
}
model = gwlars(Y~X+Z, data=model.data, coords=loc, gweight=bisquare, bw=bw, verbose=FALSE, longlat=FALSE, adapt=TRUE, s=seq(0,5,length.out=5000))
gwr.heatmap <- function(model, variable) { #
    #Prepare something for plotting:#
    name.var = variable#
    var = vector()#
    for (i in 1:length(model)) {#
        var = c(var, model[['coef.scale']][i][[name.var]] * coef.lars(model[['model']][[i]], mode=model[['mode']], s=model[['s']][i])[[name.var]])#
    }#
    df.plot = data.frame(output=var)#
    #Isolate the variable to plot:#
    locations = model[['coords']]#
    coef.surface = as.data.frame(cbind(locations, var))#
    names(coef.surface)[3] = name.var#
    #Heatmap of the data#
    locations = list(lat=unique(locations[,2]), long=unique(locations[,1]))#
    mat = matrix(NA, nrow=length(locations[['lat']]), ncol=length(locations[['long']]))#
    rownames(mat) <- sort(unique(coef.surface[,2]), decreasing=F)#
    colnames(mat) <- sort(unique(coef.surface[,1]), decreasing=F)         #
    #Put the coefficients into a lat-long matrix#
    for(row in 1:dim(coef.surface)[1]) {#
        mat[as.character(coef.surface[row,2]), as.character(coef.surface[row,1])] = #
            ifelse(!is.na(coef.surface[row,name.var]), coef.surface[row,name.var], NA)#
    }#
#
    #par(bty='n')#
    gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)#
}
model[['coef.scale']][1]
model[['coef.scale']][1][['X']]
model[['coef.scale']][1][[1]][['X']]
gwr.heatmap <- function(model, variable) { #
    #Prepare something for plotting:#
    name.var = variable#
    var = vector()#
    for (i in 1:length(model)) {#
        var = c(var, model[['coef.scale']][i][[1]][[name.var]] * coef.lars(model[['model']][[i]], mode=model[['mode']], s=model[['s']][i])[[name.var]])#
    }#
    df.plot = data.frame(output=var)#
    #Isolate the variable to plot:#
    locations = model[['coords']]#
    coef.surface = as.data.frame(cbind(locations, var))#
    names(coef.surface)[3] = name.var#
    #Heatmap of the data#
    locations = list(lat=unique(locations[,2]), long=unique(locations[,1]))#
    mat = matrix(NA, nrow=length(locations[['lat']]), ncol=length(locations[['long']]))#
    rownames(mat) <- sort(unique(coef.surface[,2]), decreasing=F)#
    colnames(mat) <- sort(unique(coef.surface[,1]), decreasing=F)         #
    #Put the coefficients into a lat-long matrix#
    for(row in 1:dim(coef.surface)[1]) {#
        mat[as.character(coef.surface[row,2]), as.character(coef.surface[row,1])] = #
            ifelse(!is.na(coef.surface[row,name.var]), coef.surface[row,name.var], NA)#
    }#
#
    #par(bty='n')#
    gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)#
}
model[['coef.scale']][2]
model[['coef.scale']][3]
gwr.heatmap(model, 'X')
model=model
variable='X'
Prepare something for plotting:#
    name.var = variable#
    var = vector()#
    for (i in 1:length(model)) {#
        var = c(var, model[['coef.scale']][i][[1]][[name.var]] * coef.lars(model[['model']][[i]], mode=model[['mode']], s=model[['s']][i])[[name.var]])#
    }#
    df.plot = data.frame(output=var)#
    #Isolate the variable to plot:#
    locations = model[['coords']]#
    coef.surface = as.data.frame(cbind(locations, var))#
    names(coef.surface)[3] = name.var#
    #Heatmap of the data#
    locations = list(lat=unique(locations[,2]), long=unique(locations[,1]))#
    mat = matrix(NA, nrow=length(locations[['lat']]), ncol=length(locations[['long']]))#
    rownames(mat) <- sort(unique(coef.surface[,2]), decreasing=F)#
    colnames(mat) <- sort(unique(coef.surface[,1]), decreasing=F)         #
    #Put the coefficients into a lat-long matrix#
    for(row in 1:dim(coef.surface)[1]) {#
        mat[as.character(coef.surface[row,2]), as.character(coef.surface[row,1])] = #
            ifelse(!is.na(coef.surface[row,name.var]), coef.surface[row,name.var], NA)#
    }#
#
    #par(bty='n')#
    gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)
locations
locations = model[['coords']]
locations
Prepare something for plotting:#
    name.var = variable#
    var = vector()#
    for (i in 1:length(model)) {#
        var = c(var, model[['coef.scale']][i][[1]][[name.var]] * coef.lars(model[['model']][[i]], mode=model[['mode']], s=model[['s']][i])[[name.var]])#
    }#
    df.plot = data.frame(output=var)#
    #Isolate the variable to plot:#
    locations = model[['coords']]#
    coef.surface = as.data.frame(cbind(locations, var))#
    names(coef.surface)[3] = name.var#
    #Heatmap of the data#
    locations = list(lat=unique(locations[,2]), long=unique(locations[,1]))#
    mat = matrix(NA, nrow=length(locations[['lat']]), ncol=length(locations[['long']]))#
    rownames(mat) <- sort(unique(coef.surface[,2]), decreasing=F)#
    colnames(mat) <- sort(unique(coef.surface[,1]), decreasing=F)         #
    #Put the coefficients into a lat-long matrix#
    for(row in 1:dim(coef.surface)[1]) {#
        mat[as.character(coef.surface[row,2]), as.character(coef.surface[row,1])] = #
            ifelse(!is.na(coef.surface[row,name.var]), coef.surface[row,name.var], NA)#
    }#
#
    #par(bty='n')#
    gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)
var = vector()#
     for (i in 1:length(model)) {#
         var = c(var, model[['coef.scale']][i][[1]][[name.var]] * coef.lars(model[['model']][[i]], mode=model[['mode']], s=model[['s']][i])[[name.var]])#
     }
var
var = vector()#
     for (i in 1:length(model[['model']])) {#
         var = c(var, model[['coef.scale']][i][[1]][[name.var]] * coef.lars(model[['model']][[i]], mode=model[['mode']], s=model[['s']][i])[[name.var]])#
     }
var
Prepare something for plotting:#
    name.var = variable#
    var = vector()#
    for (i in 1:length(model[['model']])) {#
        var = c(var, model[['coef.scale']][i][[1]][[name.var]] * coef.lars(model[['model']][[i]], mode=model[['mode']], s=model[['s']][i])[[name.var]])#
    }#
    df.plot = data.frame(output=var)#
    #Isolate the variable to plot:#
    locations = model[['coords']]#
    coef.surface = as.data.frame(cbind(locations, var))#
    names(coef.surface)[3] = name.var#
    #Heatmap of the data#
    locations = list(lat=unique(locations[,2]), long=unique(locations[,1]))#
    mat = matrix(NA, nrow=length(locations[['lat']]), ncol=length(locations[['long']]))#
    rownames(mat) <- sort(unique(coef.surface[,2]), decreasing=F)#
    colnames(mat) <- sort(unique(coef.surface[,1]), decreasing=F)         #
    #Put the coefficients into a lat-long matrix#
    for(row in 1:dim(coef.surface)[1]) {#
        mat[as.character(coef.surface[row,2]), as.character(coef.surface[row,1])] = #
            ifelse(!is.na(coef.surface[row,name.var]), coef.surface[row,name.var], NA)#
    }#
#
    #par(bty='n')#
    gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)
