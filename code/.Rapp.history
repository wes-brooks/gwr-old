se.lambda.p**2
grad.p = matrix(c(-exp(-lsigma.p - mu.p*exp(-lsigma.p)), 0, mu * exp(-mu.p * exp(-lsigma.p) - lsigma.p), -exp(-lsigma.p)), 2, 2)
t(grad.p) %*% perc.model$var %*% grad.p
t(grad.p) %*% perc.model$var %*% grad.p[1,1]
sqrt((t(grad.p) %*% perc.model$var %*% grad.p)[1,1])
grad.alpha.p
grad
grad = matrix(c(-exp(-lsigma - mu*exp(-lsigma)), mu * exp(-lsigma - mu*exp(-lsigma)), 0, -exp(-lsigma)), 2, 2)
t(grad) %*% perc.model$var %*% grad
grad
grad.p
grad.lambda.p
grad = matrix(c(exp(-lsigma - mu*exp(-lsigma)), mu * exp(-lsigma - mu*exp(-lsigma)), 0, -exp(-lsigma)), 2, 2)
t(grad) %*% perc.model$var %*% grad
se.alpha.p**2
Load the data and the survival library#
library(survival)#
library(KMsurv)#
data(kidney)#
#
#Create a Weibull survival regression model#
perc.model = survreg(Surv(time, delta)~1, data=kidney[kidney$type==2,], dist='weibull')#
surg.model = survreg(Surv(time, delta)~1, data=kidney[kidney$type==1,], dist='weibull')#
#Percutaneous implantation:#
#Extract the parameters as lambda and alpha:#
mu.p = perc.model$coef[["(Intercept)"]]#
lsigma.p = perc.model$scale#
lambda.p = exp(-mu.p * exp(-lsigma.p))#
alpha.p = 1 / exp(lsigma.p)#
#
#Apply the delta method to get the variance of the transformed params:#
grad.lambda.p = matrix(c(-exp(-lsigma.p - mu.p*exp(-lsigma.p)), #
                            mu.p * exp(-lsigma.p - mu.p*exp(-lsigma.p))), 2, 1)#
var.lambda.p = t(grad.lambda.p) %*% perc.model$var %*% grad.lambda.p#
se.lambda.p = sqrt(var.lambda.p)#
#lambda=0.428, se.lambda=0.158#
#
grad.alpha.p = matrix(c(0, -exp(-lsigma.p)), 2, 1)#
var.alpha.p = t(grad.alpha.p) %*% perc.model$var %*% grad.alpha.p#
se.alpha.p = sqrt(var.alpha.p)#
#alpha=0.157, se.alpha=0.042#
#Surgical implantation:#
#Extract the parameters as lambda and alpha:#
mu.s = surg.model$coef[["(Intercept)"]]#
lsigma.s = surg.model$scale#
lambda.s = exp(-mu.s * exp(-lsigma.s))#
alpha.s = 1 / exp(lsigma.s)#
#
#Apply the delta method to get the variance of the transformed params:#
grad.lambda.s = matrix(c(-exp(-lsigma.s - mu.s*exp(-lsigma.s)),#
                            mu.s * exp(-lsigma.s - mu.s*exp(-lsigma.s))), 2, 1)#
var.lambda.s = t(grad.lambda.s) %*% surg.model$var %*% grad.lambda.s#
se.lambda.s = sqrt(var.lambda.s)#
#lambda=0.182, se.lambda=0.072#
#
grad.alpha.s = matrix(c(0, -exp(-lsigma.s)), 2, 1)#
var.alpha.s = t(grad.alpha.s) %*% surg.model$var %*% grad.alpha.s#
se.alpha.s = sqrt(var.alpha.s)#
#alpha=0.534, se.alpha=0.108#
#Tests for alpha=1:#
#Percutaneous implantation:#
#Wald test:#
W.p = (alpha.p-1)/se.alpha.p #
p.W.p = 1 - pchisq(W.p**2, df=1)#
#W.p=-20.2 => p<10**(-16)#
#
#Log-likelihood test: generate a null-hypothesis model with the scale fixed at 1#
perc.model.0 = survreg(Surv(time, delta)~1, data=kidney[kidney$type==2,], dist='weibull', scale=1)#
L.p = 2*(perc.model[['loglik']][1] - perc.model.0[['loglik']][1])#
p.L.p = 1-pchisq(L.p, df=1)#
#L.p=7.18 => p=0.008#
#Surgical implantation:#
#Wald test:#
W.s = (alpha.s-1)/se.alpha.s #
p.W.s = 1 - pchisq(W.s**2, df=1)#
#W.s=-4.31 => p<10**(-4)#
#
#Log-likelihood test: generate a null-hypothesis model with the scale fixed at 1#
surg.model.0 = survreg(Surv(time, delta)~1, data=kidney[kidney$type==1,], dist='weibull', scale=1)#
L.s = 2*(surg.model[['loglik']][1] - surg.model.0[['loglik']][1])#
p.L.s = 1-pchisq(L.s, df=1)#
#L.s=4.28 => p=0.039#
#Value of survival function at five months:#
#Percutaneous implantation:#
S.p = exp(-lambda.p * 5**alpha.p)#
grad = matrix(c(-exp(-lsigma - mu*exp(-lsigma)), mu * exp(-lsigma - mu*exp(-lsigma)), 0, -exp(-lsigma)), 2, 2)
p.W.s
W.s
p.W.p
W.p
lambda.p
se.lambda.p
se.lambda.s
lambda.s
Load the data and the survival library#
library(survival)#
library(KMsurv)#
data(kidney)#
#
#Create a Weibull survival regression model#
perc.model = survreg(Surv(time, delta)~1, data=kidney[kidney$type==2,], dist='weibull')#
surg.model = survreg(Surv(time, delta)~1, data=kidney[kidney$type==1,], dist='weibull')#
#Percutaneous implantation:#
#Extract the parameters as lambda and alpha:#
mu.p = perc.model$coef[["(Intercept)"]]#
lsigma.p = perc.model$scale#
lambda.p = exp(-mu.p * exp(-lsigma.p))#
alpha.p = 1 / exp(lsigma.p)#
#
#Apply the delta method to get the variance of the transformed params:#
grad.p = matrix(c(-exp(-lsigma.p - mu.p*exp(-lsigma.p)), #
                    mu.p * exp(-lsigma.p - mu.p*exp(-lsigma.p)), 0, -exp(-lsigma.p)), 2, 2)#
var.p = t(grad.p) %*% perc.model$var %*% grad.p#
#
se.p = sqrt(var.p[1,1])#
#lambda=0.428, se.lambda=0.054#
#
se.alpha.p = sqrt(var.p[2,2])#
#alpha=0.157, se.alpha=0.042#
#Surgical implantation:#
#Extract the parameters as lambda and alpha:#
mu.s = surg.model$coef[["(Intercept)"]]#
lsigma.s = surg.model$scale#
lambda.s = exp(-mu.s * exp(-lsigma.s))#
alpha.s = 1 / exp(lsigma.s)#
#
#Apply the delta method to get the variance of the transformed params:#
grad.s = matrix(c(-exp(-lsigma.s - mu.s*exp(-lsigma.s)),#
                    mu.s * exp(-lsigma.s - mu.s*exp(-lsigma.s)), 0, -exp(-lsigma.s)), 2, 2)#
var.s = t(grad.s) %*% surg.model$var %*% grad.s#
#
se.lambda.s = sqrt(var.s[1,1])#
#lambda=0.182, se.lambda=0.057#
#
se.alpha.s = sqrt(var.s[2,2])#
#alpha=0.534, se.alpha=0.108#
#Tests for alpha=1:#
#Percutaneous implantation:#
#Wald test:#
W.p = (alpha.p-1)/se.alpha.p #
p.W.p = 1 - pchisq(W.p**2, df=1)#
#W.p=-20.2 => p<10**(-16)#
#
#Log-likelihood test: generate a null-hypothesis model with the scale fixed at 1#
perc.model.0 = survreg(Surv(time, delta)~1, data=kidney[kidney$type==2,], dist='weibull', scale=1)#
L.p = 2*(perc.model[['loglik']][1] - perc.model.0[['loglik']][1])#
p.L.p = 1-pchisq(L.p, df=1)#
#L.p=7.18 => p=0.008#
#Surgical implantation:#
#Wald test:#
W.s = (alpha.s-1)/se.alpha.s #
p.W.s = 1 - pchisq(W.s**2, df=1)#
#W.s=-4.31 => p<10**(-4)#
#
#Log-likelihood test: generate a null-hypothesis model with the scale fixed at 1#
surg.model.0 = survreg(Surv(time, delta)~1, data=kidney[kidney$type==1,], dist='weibull', scale=1)#
L.s = 2*(surg.model[['loglik']][1] - surg.model.0[['loglik']][1])#
p.L.s = 1-pchisq(L.s, df=1)#
#L.s=4.28 => p=0.039#
#Value of survival function at five months:#
#Percutaneous implantation:#
S.p = exp(-lambda.p * 5**alpha.p)
W.p
se.lambda.s
lambda.s
se.lambda.p
se.alpha.p
se.alpha.s
se.lambda.s
S.p
grad.surv <- function(t, a, l) {#
    return( matrix(c(-t**a * exp(-l * t**a), -l * t**a * log(t) * exp(-l * t**a)), 2, 1) )#
}
grad.surv(5, alpha.p, lambda.p)
g = grad.surv(5, alpha.p, lambda.p)
t(g) %*% var.p %*% g
sqrt(t(g) %*% var.p %*% g)
S.p
S.p = exp(-lambda.p * 5**alpha.p)#
g.p = grad.surv(5, alpha.p, lambda.p)#
se.S.p = sqrt(t(g.p) %*% var.p %*% g.p)
se.S.p
S.p=2*se.S.p
S.p = exp(-lambda.p * 5**alpha.p)
S.p-2*se.S.p
S.p+2*se.S.p
S.s = exp(-lambda.s * 5**alpha.s)#
g.s = grad.surv(5, alpha.s, lambda.s)#
se.S.s = sqrt(t(g.s) %*% var.s %*% g.s)#
#S.p=0.577, se.S.p=0.029 => 95% CI = (0.519, 0.634)
S.s
se.S.s
S.s-2*se.S.s
S.s+2*se.S.s
Simulate data for testing a GWR model:#
source("utils.r")#
library(lars)#
library(spgwr)#
#
#Set up the location grid:#
N = 20#
x = rep(0:N - N/2, each=N+1)#
y = rep(0:N - N/2, times=N+1)#
#
#Simulate the predictors independently of location:#
mu.A = 0#
sig.A = 1#
A = rnorm((N+1)**2, mu.A, sig.A)#
#
mu.B = 1#
sig.B = 2#
B = rnorm((N+1)**2, mu.B, sig.B)#
#
mu.C = -1#
sig.C = 3#
C = rnorm((N+1)**2, mu.C, sig.C)#
#
#Simulate the output variable:#
sig.err = 0.5#
out = y + A*x + B + rnorm((N+1)**2, 0, sig.err)#
#
simulated = data.frame(x, y, A, B, C, out)#
#
#Use the methods of spgwr to select a bandwidth and fit a GWR model for poverty:#
bw = gwr.sel(out~A+B+C, data=simulated, coords=cbind(x,y), adapt=FALSE, gweight=gwr.bisquare)#
gwr.sim = gwr(out~A+B+C, data=simulated, coords=cbind(x,y), bandwidth=bw, gweight=gwr.bisquare)#
#Homebrew GWR:#
df = simulated#
#
#Define which variables we'll use as predictors of poverty:#
predictors = c('A', 'B', 'C')#
output = 'out'#
f = as.formula(paste("out ~ 1 + ", paste(predictors, collapse="+"), sep=""))#
#
#Make a new variable with the name of each predictor:#
for (col in predictors) {#
    assign(col, vector())#
}#
#
#Use this trick to compute the matrix of distances very quickly#
n = dim(df)[1]#
D1 = matrix(rep(df$x,n), n,n)#
D2 = matrix(rep(df$y,n), n,n)#
D = sqrt((D1-t(D1))**2 + (D2-t(D2))**2)#
#
#Use the lasso for GWR model selection:#
w.lasso.geo = list()#
coefs = list()#
diagnostics = list()#
#
for(i in 1:dim(df)[1]) {#
    w = bisquare(D[,i], bw=bw)#
#
    model = lm(f, data=df, weights=w)#
    w.eig <- eigen(diag(w))#
    w.sqrt <- w.eig$vectors %*% diag(sqrt(w.eig$values)) %*% solve(w.eig$vectors)#
    w.lasso.geo[[i]] = lars(x=w.sqrt %*% as.matrix(df[,predictors]), y=as.matrix(df[[output]]))#
    for (col in predictors) {#
        coefs[[col]] = c(coefs[[col]], model$coef[[col]])#
    }#
    coefs[['(Intercept)']] = c(coefs[['(Intercept)']], model$coef[['(Intercept)']])#
#
    diagnostics[['R2']] = c(diagnostics[['R2']], summary(model)[['r.squared']])#
    diagnostics[['sigma']] = c(diagnostics[['sigma']], summary(model)[['sigma']])#
    diagnostics[['total weight']] = c(diagnostics[['total weight']], sum(w))#
    print(i)#
}#
#
model = list(coords=df[,c('x','y')], coefs=coefs, diags=diagnostics, lasso=w.lasso.geo)
y=seq(1,100)
sum(1/factorial(y))
y=seq(0,100)
sum(1/factorial(y))
e
exp(1)
exp(1)/(exp(1)-1)
y=seq(1,100)
sum(y/factorial(y))
sum(y/factorial(y) / (exp(1)-1))
sum(exp(y)/factorial(y) / (exp(1)-1))
sum(exp(2*y)/factorial(y) / (exp(1)-1))
sum(exp(3*y)/factorial(y) / (exp(1)-1))
install.packages("knitr")
setwd("git/gwr/data/NorthernWisconsin/Data-Chongyang/")
landcover = read.csv("landcover.csv", head=TRUE)
names(landcover)
landciover[1:10,]
landcover[1:10,]
wi=readShapePoly("qscppoly")#
ashqs = which(unique(wi@data$DTRSQ) == landcover$ID)#
ash = wi@polygons[ashqs]
library(sp)
wi=readShapePoly("qscppoly")#
ashqs = which(unique(wi@data$DTRSQ) == landcover$ID)#
ash = wi@polygons[ashqs]
setwd("../plss_quarter-sections/")
library(maptools)#
wi=readShapePoly("qscppoly")#
ashqs = which(unique(wi@data$DTRSQ) == landcover$ID)#
ash = wi@polygons[ashqs]
ashqs = which(unique(wi@data$DTRSQ) %in% landcover$ID)#
ash = wi@polygons[ashqs]
ashqs
length(ashqs)
ash
ash[[1]]
ash[[2]]
ash[[3]]
ash[[4]]
ash[[4]][[1]]
ash[[4]][['coords']]
ash[[4]]@Polygons[[1]]
ash[[4]]@Polygons[[1]][['coords']]
ash[[4]]@Polygons[[1]]@coords
ash[[4]]@Polygons[[1]]@coords[,1]
91.24667 - arctan((ash[[4]]@Polygons[[1]]@coords[,1]-423538)/4402443)
91.24667 - atan((ash[[4]]@Polygons[[1]]@coords[,1]-423538)/4402443)
46.35056 + atan((ash[[4]]@Polygons[[1]]@coords[,2]-653773)/6378100)
wi@data$DTRSQ
landcover$ID
unique(wi@data$DTRSQ)[ashqs]
unique(wi@data$DTRSQ)[ashqs][1]
which(wi@data$DTRSQ == 24803094)
wi[[5896]]
wi@data[[5896]]
wi@polygons[[5896]]
wi@polygons[[5897]]
landcover$ID
which(unique(wi@data$DTRSQ) %in% landcover$ID)
which(wi@data$DTRSQ %in% landcover$ID)
wi@data$DTRSQ[5896] %in% landcover$ID
wi@data$DTRSQ[5043] %in% landcover$ID
length(landcover$ID)
ashqs = which(unique(wi@data$DTRSQ) %in% landcover$ID)#
ash = wi@polygons[ashqs]
ashqs = which(wi@data$DTRSQ %in% landcover$ID)#
ash = wi@polygons[ashqs]#
#
ash.coords = data.frame()#
for (k in 1:length(ashqs)) {#
    ash.coords = rbind(ash.coords, cbind(91.24667 - atan((ash[[k]][[1]]@Polygons[[1]]@coords[,1]-423538)/4402443), 46.35056 + atan((ash[[k]]@Polygons[[1]]@coords[,2]-653773)/6378100), rep(wi@data$DTRSQ[ashqs[k]],nrow(ash[[k]][[1]]@Polygons[[1]]@coords))))#
}
ash.coords = data.frame()#
for (k in 1:length(ashqs)) {#
    ash.coords = rbind(ash.coords, cbind(91.24667 - atan((ash[[k]]@Polygons[[1]]@coords[,1]-423538)/4402443), 46.35056 + atan((ash[[k]]@Polygons[[1]]@coords[,2]-653773)/6378100), rep(wi@data$DTRSQ[ashqs[k]],nrow(ash[[k]][[1]]@Polygons[[1]]@coords))))#
}
ash.coords = data.frame()#
for (k in 1:length(ashqs)) {#
    ash.coords = rbind(ash.coords, cbind(91.24667 - atan((ash[[k]]@Polygons[[1]]@coords[,1]-423538)/4402443), 46.35056 + atan((ash[[k]]@Polygons[[1]]@coords[,2]-653773)/6378100), rep(wi@data$DTRSQ[ashqs[k]],nrow(ash[[k]]@Polygons[[1]]@coords))))#
}
ash.coords[1:10,]
aa = ash.coords#
names(aa) = c('x','y','DTRSQ')
mergedata <- merge(aa, landcover, by.x='DTRSQ', by.y='ID')
mergedata[1:30,]
mergedata$out = rnorm(nrow(mergedata))
map <- ggplot(mergedata, aes(x,y,group=DTRSQ)) + geom_polygon(aes(fill=out))#
    map <- map + scale_fill_gradient(low='white', high='red', limits=range(mergedata$out, na.rm=TRUE), name='coef') + coord_map(project='globular')
librart(ggplots)
librart(ggplot2)
library(ggplot2)
map <- ggplot(mergedata, aes(x,y,group=DTRSQ)) + geom_polygon(aes(fill=out))#
    map <- map + scale_fill_gradient(low='white', high='red', limits=range(mergedata$out, na.rm=TRUE), name='coef') + coord_map(project='globular')
map
map
mergedata$y = -mergedata$y
map
mergedata$y = -mergedata$y
mergedata$x = -mergedata$x
map
map <- ggplot(mergedata, aes(x,y,group=DTRSQ)) + geom_polygon(aes(fill=out))#
    map <- map + scale_fill_gradient(low='white', high='red', limits=range(mergedata$out, na.rm=TRUE), name='coef') + coord_map(project='globular')
map
str(landcover)
landcover[1:10,]
landcover$APB.87 = ifelse(landcover$Cover1987=="Aspen-Paper Birch",1,0)
gwglmnet.sel(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial')
library(fossil)#
#
gwglmnet.sel = function(formula, data=list(), coords, adapt=FALSE, nearest.neighbors=FALSE, gweight=gwr.Gauss, s, method="cv", verbose=FALSE, longlat=FALSE, family, weights, tol=.Machine$double.eps^0.25) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)#
    m <- match(c("formula", "data", "weights"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))#
    weights <- as.vector(model.extract(mf, "weights"))#
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    #Get the matrix of distances#
    n = dim(coords)[1]#
    if (longlat) {#
        D = as.matrix(earth.dist(coords),n,n)#
    } else {#
        Xmat = matrix(rep(coords[,1], times=n), n, n)#
        Ymat = matrix(rep(coords[,2], times=n), n, n)#
        D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
    }#
#
    if (nearest.neighbors) {#
        beta1 <- 0#
        beta2 <- 1#
    } else {#
        bbox <- cbind(range(coords[, 1]), range(coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
        beta1 <- difmin/1000#
        beta2 <- 10 * difmin        #
    }#
#
    opt <- optimize(gwglmnet.cv.f, lower=beta1, upper=beta2, #
        maximum=FALSE, tol=tol, formula=formula, coords=coords, s=s,#
        gweight=gweight, verbose=verbose, longlat=longlat, data=data, D=D,#
        weights=weights, adapt=adapt, nn=nearest.neighbors, family=family)#
    bdwt <- opt$minimum#
    res <- bdwt#
#
    res#
}#
gwglmnet.cv.f = function(formula, data, bw, coords, gweight, verbose, adapt, longlat, s, family, weights, nn, D=NULL, ...) {    #
    #Generate the model with the given bandwidth:#
    cat(paste('Beginning with bandwidth: ', bw, '\n', sep=''))#
    gwglmnet.model = gwglmnet(formula=formula, data=data, coords=coords, gweight=gweight, bw=bw, verbose=verbose, longlat=longlat, adapt=adapt, s=s, family=family, weights=weights, nearest.neighbors=nn, D=D )#
    cv.error = sum(sapply(gwglmnet.model[['cv.error']], min))#
#
    cat(paste('Bandwidth: ', bw, '. CV error: ', cv.error, '\n', sep=''))#
    return(cv.error)#
}
gwglmnet <- function(formula, data, coords, gweight, bw, D=NULL, verbose=FALSE, longlat=FALSE, adapt=FALSE, s, family, weights=NULL, nearest.neighbors=FALSE) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)    #
    #m <- match(c("formula", "data", "weights"), names(mf), 0)#
    m <- match(c("formula", "data"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))      #
    #weights <- as.vector(model.extract(mf, "weights"))    #
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    if (is.null(D)) {#
        #Get the matrix of distances#
        n = dim(coords)[1]#
        if (longlat) {#
            D = as.matrix(earth.dist(coords),n,n)#
        } else {#
            Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
        }#
    }    #
#
    #Get the weight matrix#
    if (!nearest.neighbors) {#
        weight.matrix = gweight(D, bw)#
    } else {#
        n = dim(D)[1]#
        bandwidths = sapply(1:n, function(x) {neighbor.weight(q=bw, D=D[x,], weight.function=gweight, verbose=verbose, tol=0.001)})#
        weight.matrix = as.matrix(rbind(sapply(1:n, function(k) {gweight(as.vector(D[k,]), as.numeric(bandwidths[1,k]))})),n,n)#
    }#
#
    if (!adapt) {#
        res = gwglmnet.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    else {#
        res = gwglmnet.adaptive.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    res[['data']] = data#
    res[['response']] = as.character(formula[[2]])#
    res#
}#
gwglmnet.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwglmnet.object = list()#
    cv.error = list()#
#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        prior.loow = prior.weights[-colocated]#
        reps = length(colocated)        #
        w <- prior.loow * loow#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        model[[i]] = glmnet(x=xx, y=cbind(1-yy, yy), weights=w, family=family, lambda=s)#
        predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), s=s, type='response')#
        cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = NULL#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}#
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        m <- ncol(xx)#
        n <- nrow(xx)#
        one <- rep(1, n)#
        meanx <- drop(one %*% xx)/n#
        x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adapt.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
        beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
        adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
        adapt.scale[[i]] = adapt.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(adapt.weight[k])) {#
                xs[,k] = xs[,k] * adapt.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        coef.scale[[i]] = adapt.weight/normx#
        names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
        model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
        predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
        cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
        s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
gwglmnet.sel(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001))
Import the plotting functions:#
library(plotrix)#
library(sp)#
library(fossil)#
setwd('~/git/gwr/code')#
source('matplot.r')#
#source('legend.r')#
#Define the bisquare weight function:#
bisquare = function(x, z, bw) {#
    ifelse( r(x=x, z=c(z[1], z[2])) < bw, (1 - (r(x=x, z=c(z[1],z[2]))/ bw)**2)**2, 0)#
}#
bisquare = function(R, bw) {#
    ifelse( R < bw, (1 - (R/bw)**2)**2, 0)#
}#
#Define the distance function#
r = function(x, z) { #
    sqrt((x[1]-z[1])**2 + (x[2]-z[2])**2)#
}#
#Fix an x.i and get the distance to all other x’s:#
R = function(x.i, xy.mat) {#
    R = sapply(1:dim(xy.mat)[1], FUN=function(i) {r(x.i, xy.mat[i,])} )#
    return(R)#
}#
W = function(x.i, xy.mat, bw) {#
    distance = R(x.i, xy.mat)#
    W = bisquare(distance, bw)#
    return(W)#
}#
neighbor.weight = function(q, D=NULL, this.coords=NULL, obs.coords=NULL, longlat=FALSE, weight.function, verbose=FALSE, tol=.Machine$double.eps^0.25) {#
    if (is.null(D)) {#
        bbox <- cbind(range(obs.coords[, 1]), range(obs.coords[, 2]))#
        difmin <- spDistsN1(bbox, bbox[2, ], longlat)[1]#
        if (any(!is.finite(difmin))) #
            difmin[which(!is.finite(difmin))] <- 0#
#
        this.coords = as.numeric(this.coords)#
        if (!longlat) {#
            nrow = dim(obs.coords)[1]#
            D2 = (matrix(as.numeric(this.coords), nrow, 2, byrow=TRUE) - obs.coords)**2#
            D2 = apply(D2, 1, sum)#
            D = sqrt(D2)#
        } else {#
            n = dim(obs.coords)[1]#
            D = sapply(1:dim(obs.coords)[1], function(x) {deg.dist(this.coords[1], this.coords[2], obs.coords[x,1], obs.coords[x,2])})#
        }#
    }#
#
    beta1 <- min(D)#
    beta2 <- 10*max(D)#
#
    optimize(neighbor.diff, lower=beta1, upper=beta2, maximum=FALSE, tol=tol, #
                D=D, weight.function=weight.function, q.target=q, verbose=verbose)#
}#
#
neighbor.diff = function(bw, D, q.target, weight.function, verbose) {#
    if (verbose) {cat(paste("bandwidth: ", bw, '\n', sep=''))}#
#
    nobs = length(D)#
    W = weight.function(D, bw)#
    q.this = sum(W)/nobs#
#
    if (verbose) {cat(paste("total weight: ", q.this, '\n', sep=''))}#
#
    return(abs(q.target - q.this))#
}#
gwr.heatmap <- function(model, variable=NULL, type='coef', cs1=c(0,1), cs2=c(0,1), cs3=c(0,1)) { #
    #Prepare something for plotting:#
    if (type=='coef') {#
        name.var = variable#
        out = vector()#
        if (is.null(model[['coef.scale']])) {#
            coefs=sapply(1:length(model[['s']]), function(k) {coef(sim.model[['model']][[k]])[,which(sim.model[['s.range']]==sim.model[['s']][k])]})#
            out = c(out, coefs[name.var,])#
        } else {#
            coefs=sapply(1:length(model[['s']]), function(k) {model[['coef.scale']][[i]][[name.var]] * coef(sim.model[['model']][[k]])[,which(sim.model[['s.range']]==sim.model[['s']][k])]})#
            out = c(out, coefs[name.var,])#
        }#
#
    } else if (type=='errors') {#
        out = sapply(1:length(model[['s']]), function(k) {t(as.matrix(as.numeric(model[['model']][[k]]$beta[,which(model[['model']][[k]]$lambda==model[['s']][k])]))) %*% as.matrix(as.numeric(c(1, model[['data']][k,c('X1', 'X2', 'Z')]),nrow=4,ncol=1)) + model[['model']][[k]][['a0']][which(model[['model']][[k]]$lambda==model[['s']][k])]}) - eta#
    } else if (type=='residuals') {#
        out = model[['data']][,model[['response']]] - sapply(1:length(model[['s']]), function(k) {t(as.matrix(as.numeric(model[['model']][[k]]$beta[,which(model[['model']][[k]]$lambda==model[['s']][k])]))) %*% as.matrix(as.numeric(c(1, model[['data']][k,c('X1', 'X2', 'Z')]),nrow=4,ncol=1)) + model[['model']][[k]][['a0']][which(model[['model']][[k]]$lambda==model[['s']][k])]})#
    } else if (type=='fit') {#
        out = sapply(1:length(model[['s']]), function(k) {t(as.matrix(as.numeric(model[['model']][[k]]$beta[,which(model[['model']][[k]]$lambda==model[['s']][k])]))) %*% as.matrix(as.numeric(c(1, model[['data']][k,c('X1', 'X2', 'Z')]),nrow=4,ncol=1)) + model[['model']][[k]][['a0']][which(model[['model']][[k]]$lambda==model[['s']][k])]})#
    } else if (type=='data') {#
        out = model[['data']][,model[['response']]]#
    }#
    df.plot = data.frame(output=out)#
#
    #return(df.plot)#
#
    #Isolate the variable to plot:#
    locations = model[['coords']]#
    coef.surface = as.data.frame(cbind(locations, out))#
    names(coef.surface)[3] = name.var#
    #Heatmap of the data#
    locations = list(lat=unique(locations[,2]), long=unique(locations[,1]))#
    mat = matrix(NA, nrow=length(locations[['lat']]), ncol=length(locations[['long']]))#
    rownames(mat) <- sort(unique(coef.surface[,2]), decreasing=F)#
    colnames(mat) <- sort(unique(coef.surface[,1]), decreasing=F)         #
    #Put the coefficients into a lat-long matrix#
    for(row in 1:dim(coef.surface)[1]) {#
        mat[as.character(coef.surface[row,2]), as.character(coef.surface[row,1])] = #
            ifelse(!is.na(coef.surface[row,name.var]), coef.surface[row,name.var], NA)#
    }#
#
    gwr.matplot(mat, cs1, cs2, cs3, border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)#
}#
gwr.heatmap.homebrew <- function(model, variable) {   #
    #Isolate the variable to plot:#
    locations = model[['coords']]#
    coef.surface = as.data.frame(cbind(locations, model[['coefs']][[variable]]))#
    names(coef.surface)[3] = variable#
    #Heatmap of the data#
    locations = with(coef.surface, list(lat=unique(y), long=unique(x)))#
    mat = matrix(NA, nrow=length(locations[['lat']]), ncol=length(locations[['long']]))#
    rownames(mat) <- sort(unique(coef.surface$y), decreasing=F)#
    colnames(mat) <- sort(unique(coef.surface$x), decreasing=F)         #
    #Put the coefficients into a lat-long matrix#
    for(row in 1:dim(coef.surface)[1]) {#
        mat[as.character(coef.surface[row,'y']), as.character(coef.surface[row,'x'])] = #
            ifelse(!is.na(coef.surface[row,variable]), coef.surface[row,variable], NA)#
    }#
#
    #par(bty='n')#
    gwr.matplot(mat, c(1,1), c(1,0), c(1,0), border=NA, show.legend=TRUE, yrev=FALSE, axes=TRUE, ann=TRUE)#
}#
plot.coef.gwr = function(model, var, locs, breaks=NULL) {#
    #Prepare something for plotting:#
    locs = merge(unique(locs), model$SDF@coords)#
    name.var = var#
    var = model$SDF@data[,name.var]#
    df.plot = data.frame(output=var)#
    #Put the county names into a form that can be matched.#
    df.plot$county = tolower(as.character(locs$county))#
    df.plot$state = tolower(as.character(locs$state))#
    for (i in 1:dim(df.plot)[1]) {#
        county = gsub("['-. ]", '', df.plot$county[i])#
        df.plot$county[i] = paste(county, tolower(df.plot$state[i]), sep=',')#
    }    #
    #extract reference data#
    mapcounties <- map_data('county')#
    mapstates <- map_data('state')#
    #limit our view to the midwest:#
    midweststates = mapstates[tolower(mapstates$region) %in% tolower(df.plot$state),]#
    midwestcounties = mapcounties[tolower(mapcounties$region) %in% tolower(df.plot$state),]#
    #merge data with ggplot county coordinates#
    midwestcounties$county <- with(midwestcounties , paste(gsub("['-. ]", '', subregion), region, sep=','))#
    mergedata <- merge(midwestcounties, df.plot, by.x='county', by.y='county')#
    mergedata <- mergedata[order(mergedata$group, mergedata$order),]#
    #draw map#
    map <- ggplot(mergedata, aes(long,lat,group=group)) + geom_polygon(aes(fill=output))#
    map <- map + scale_fill_gradient(low='white', high='red', limits=range(df.plot$output, na.rm=TRUE), name='coef') + coord_map(project='globular')#
    map <- map + opts(panel.background=theme_rect(fill='green', colour='red'))#
    #add state borders#
    map <- map + geom_path(data=midweststates, colour='white', size=0.75)#
    #add county borders#
    map <- map + geom_path(data=midwestcounties, colour='white', size=0.5, alpha=0.1)#
    map + opts(title=paste("Coefficient of '", name.var, "' in a model for logitindpov without LARS", sep='')) #+ guides(fill=guide_legend(reverse=TRUE))#
}#
plot.coef.gwlars = function(model, var, locs, data, s=NULL, breaks=NULL) {#
    #Prepare something for plotting:#
    name.var = var#
    var = vector()#
    for (i in 1:length(model)) {#
        var = c(var, coef.lars(model[['model']][[i]], mode=model[['mode']], s=model[['s']][i])[[name.var]])#
    }#
    df.plot = data.frame(output=var)#
    #Put the county names into a form that can be matched.#
    df.plot$county = tolower(as.character(locs$county))#
    df.plot$state = tolower(as.character(locs$state))#
    for (i in 1:dim(df.plot)[1]) {#
        county = gsub("['-. ]", '', df.plot$county[i])#
        df.plot$county[i] = paste(county, tolower(df.plot$state[i]), sep=',')#
    }    #
    #extract reference data#
    mapcounties <- map_data('county')#
    mapstates <- map_data('state')#
    #limit our view to the midwest:#
    midweststates = mapstates[tolower(mapstates$region) %in% tolower(df.plot$state),]#
    midwestcounties = mapcounties[tolower(mapcounties$region) %in% tolower(df.plot$state),]#
    #merge data with ggplot county coordinates#
    midwestcounties$county <- with(midwestcounties , paste(gsub("['-. ]", '', subregion), region, sep=","))#
    mergedata <- merge(midwestcounties, df.plot, by.x = "county", by.y = "county")#
    mergedata <- mergedata[order(mergedata$group, mergedata$order),]#
    #draw map#
    map <- ggplot(mergedata, aes(long,lat,group=group)) + geom_polygon(aes(fill=output))#
    if (mean(df.plot$output, na.rm=TRUE)<=0) {       #
        map <- map + scale_fill_gradient(low='red', high='white', limits=range(df.plot$output, na.rm=TRUE), name='coef') + coord_map(project='globular')#
    } else {#
        map <- map + scale_fill_gradient(low='white', high='red', limits=range(df.plot$output, na.rm=TRUE), name='coef') + coord_map(project='globular')#
    }#
#
    map <- map + opts(panel.background=theme_rect(fill='green', colour='red'))#
    #add state borders#
    map <- map + geom_path(data=midweststates, colour='white', size=0.75)#
    #add county borders#
    map <- map + geom_path(data=midwestcounties, colour='white', size=0.5, alpha=0.1)#
    map + opts(title=paste("Coefficient of '", name.var, "' in a model for logitindpov", sep='')) #+ guides(fill=guide_legend(reverse=TRUE))#
}#
plot.effect.gwlars = function(model, var, locs, l, data, breaks=NULL) {#
    #Prepare something for plotting:#
    name.var = var#
    var = vector()#
    col.out = which(names(data)=='logitindpov')#
    for (i in 1:length(model)) {#
        var = c(var, data[[name.var]][i]*coef.lars(model[[i]], newx=data[i,-col.out], mode='lambda', s=l[i])[[name.var]])#
    }#
#
    df.plot = data.frame(output=var)#
#
    #Put the county names into a form that can be matched.#
    df.plot$county = tolower(as.character(locs$county))#
    df.plot$state = tolower(as.character(locs$state))#
    for (i in 1:dim(df.plot)[1]) {#
        county = gsub("['-. ]", '', df.plot$county[i])#
        df.plot$county[i] = paste(county, tolower(df.plot$state[i]), sep=',')#
    }#
    #extract reference data#
    mapcounties <- map_data('county')#
    mapstates <- map_data('state')#
    #limit our view to the midwest:#
    midweststates = mapstates[tolower(mapstates$region) %in% tolower(df.plot$state),]#
    midwestcounties = mapcounties[tolower(mapcounties$region) %in% tolower(df.plot$state),]#
    #merge data with ggplot county coordinates#
    midwestcounties$county <- with(midwestcounties , paste(gsub("['-. ]", '', subregion), region, sep=','))#
    mergedata <- merge(midwestcounties, df.plot, by.x = 'county', by.y = 'county')#
    mergedata <- mergedata[order(mergedata$group, mergedata$order),]#
    #draw map#
    map <- ggplot(mergedata, aes(long,lat,group=group)) + geom_polygon(aes(fill=output))#
    map <- map + scale_fill_gradient(low='white', high='red', limits=range(df.plot$output, na.rm=TRUE), name='effect') + coord_map(project="globular")#
    map <- map + opts(panel.background=theme_rect(fill='green', colour='red'))#
    #add state borders#
    map <- map + geom_path(data=midweststates, colour='white', size=0.75)#
    #add county borders#
    map <- map + geom_path(data=midwestcounties, colour='white', size=0.5, alpha=0.1)#
    map + opts(title=paste(c('Coefficient of ', name.var, ' in a model for logitindpov'), collapse='')) #+ guides(fill=guide_legend(reverse=TRUE))#
}#
plot.residuals.gwlars = function(model, locs, l, data, breaks=NULL) {#
    #Prepare something for plotting:#
    err = vector()#
    col.out = which(names(data)=='logitindpov')#
    for (i in 1:length(model)) {#
        err = c(err, predict.lars(model[[i]], newx=data[i,-col.out], mode='lambda', s=l[i])[['fit']] - data[i,col.out])#
    }#
    df.plot = data.frame(output=err)#
    #Put the county names into a form that can be matched.#
    df.plot$county = tolower(as.character(locs$county))#
    df.plot$state = tolower(as.character(locs$state))#
    for (i in 1:dim(df.plot)[1]) {#
        county = gsub("['-. ]", '', df.plot$county[i])#
        df.plot$county[i] = paste(c(county, tolower(df.plot$state[i])), collapse=',')#
    }    #
    #extract reference data#
    mapcounties <- map_data('county')#
    mapstates <- map_data('state')#
    #limit our view to the midwest:#
    midweststates = mapstates[tolower(mapstates$region) %in% tolower(df.plot$state),]#
    midwestcounties = mapcounties[tolower(mapcounties$region) %in% tolower(df.plot$state),]#
    #merge data with ggplot county coordinates#
    midwestcounties$county <- with(midwestcounties , paste(gsub("['-. ]", '', subregion), region, sep=","))#
    mergedata <- merge(midwestcounties, df.plot, by.x = "county", by.y = "county")#
    mergedata <- mergedata[order(mergedata$group, mergedata$order),]#
    #draw map#
    map <- ggplot(mergedata, aes(long,lat,group=group)) + geom_polygon(aes(fill=output))#
    if (mean(df.plot$output, na.rm=TRUE)<=0)       #
        map <- map + scale_fill_gradient(low='red', high='white', limits=range(df.plot$output, na.rm=TRUE), name='coef') + coord_map(project='globular')#
    else#
        map <- map + scale_fill_gradient(low='white', high='red', limits=range(df.plot$output, na.rm=TRUE), name='coef') + coord_map(project='globular')#
    map <- map + opts(panel.background=theme_rect(fill='green', colour='red'))#
    #add state borders#
    map <- map + geom_path(data=midweststates, colour='white', size=0.75)#
    #add county borders#
    map <- map + geom_path(data=midwestcounties, colour='white', size=0.5, alpha=0.1)#
    map + opts(title=paste("Residuals in a GW-LARS model for logitindpov", sep='')) #+ guides(fill=guide_legend(reverse=TRUE))#
}#
plot.sign.resid.gwlars = function(model, locs, l, data, breaks=NULL) {#
    #Prepare something for plotting:#
    err = vector()#
    col.out = which(names(data)=='logitindpov')#
    for (i in 1:length(model)) {#
        err = c(err, predict.lars(model[[i]], newx=data[i,-col.out], mode='lambda', s=l[i])[['fit']] - data[i,col.out])#
    }#
    df.plot = data.frame(output=sign(err))#
    #Put the county names into a form that can be matched.#
    df.plot$county = tolower(as.character(locs$county))#
    df.plot$state = tolower(as.character(locs$state))#
    for (i in 1:dim(df.plot)[1]) {#
        county = gsub("['-. ]", '', df.plot$county[i])#
        df.plot$county[i] = paste(county, tolower(df.plot$state[i]), sep=',')#
    }    #
    #extract reference data#
    mapcounties <- map_data('county')#
    mapstates <- map_data('state')#
    #limit our view to the midwest:#
    midweststates = mapstates[tolower(mapstates$region) %in% tolower(df.plot$state),]#
    midwestcounties = mapcounties[tolower(mapcounties$region) %in% tolower(df.plot$state),]#
    #merge data with ggplot county coordinates#
    midwestcounties$county <- with(midwestcounties , paste(gsub("['-. ]", '', subregion), region, sep=","))#
    mergedata <- merge(midwestcounties, df.plot, by.x = "county", by.y = "county")#
    mergedata <- mergedata[order(mergedata$group, mergedata$order),]#
    #draw map#
    #map <- ggplot(mergedata, aes(long,lat,group=group)) + geom_polygon(aes(fill=output))#
    map <- ggplot(mergedata, aes(long,lat,group=group)) + geom_polygon(aes(fill=output))#
    map <- map + scale_fill_gradient(low='red', high='white', limits=range(df.plot$output, na.rm=TRUE), name='coef') + coord_map(project='globular')#
    map <- map + opts(panel.background=theme_rect(fill='green', colour='red'))#
    #add state borders#
    map <- map + geom_path(data=midweststates, colour='white', size=0.75)#
    #add county borders#
    map <- map + geom_path(data=midwestcounties, colour='white', size=0.5, alpha=0.1)#
    map + opts(title=paste("Residuals in a GW-LARS model for logitindpov", sep='')) #+ guides(fill=guide_legend(reverse=TRUE))#
}#
plot.residuals.gwr = function(model, locs, l, data, breaks=NULL) {#
    #Prepare something for plotting:#
    err = vector()#
    col.out = which(names(data)=='logitindpov')#
    for (i in 1:length(model)) {#
        err = c(err, predict.gwr(model[[i]], newx=data[i,-col.out], mode='lambda', s=l[i])[['fit']] - data[i,col.out])#
    }#
    df.plot = data.frame(output=err)#
    #Put the county names into a form that can be matched.#
    df.plot$county = tolower(as.character(locs$county))#
    df.plot$state = tolower(as.character(locs$state))#
    for (i in 1:dim(df.plot)[1]) {#
        county = gsub("['-. ]", '', df.plot$county[i])#
        df.plot$county[i] = paste(county, tolower(df.plot$state[i]), sep=',')#
    }    #
    #extract reference data#
    mapcounties <- map_data('county')#
    mapstates <- map_data('state')#
    #limit our view to the midwest:#
    midweststates = mapstates[tolower(mapstates$region) %in% tolower(df.plot$state),]#
    midwestcounties = mapcounties[tolower(mapcounties$region) %in% tolower(df.plot$state),]#
    #merge data with ggplot county coordinates#
    midwestcounties$county <- with(midwestcounties , paste(gsub("['-. ]", '', subregion), region, sep=","))#
    mergedata <- merge(midwestcounties, df.plot, by.x = "county", by.y = "county")#
    mergedata <- mergedata[order(mergedata$group, mergedata$order),]#
    #draw map#
    map <- ggplot(mergedata, aes(long,lat,group=group)) + geom_polygon(aes(fill=output))#
    if (mean(df.plot$output, na.rm=TRUE)<=0)      #
        map <- map + scale_fill_gradient(low='red', high='white', limits=range(df.plot$output, na.rm=TRUE), name='coef') + coord_map(project='globular')#
    else#
        map <- map + scale_fill_gradient(low='white', high='red', limits=range(df.plot$output, na.rm=TRUE), name='coef') + coord_map(project='globular')#
    map <- map + opts(panel.background=theme_rect(fill='green', colour='red'))#
    #add state borders#
    map <- map + geom_path(data=midweststates, colour='white', size=0.75)#
    #add county borders#
    map <- map + geom_path(data=midwestcounties, colour='white', size=0.5, alpha=0.1)#
    map + opts(title=paste("Residuals in a GW-LARS model for logitindpov", sep='')) #+ guides(fill=guide_legend(reverse=TRUE))#
}#
plot.coef.gwglmnet = function(model, var, breaks=NULL) {#
    #Prepare something for plotting:#
    name.var = var#
    var = vector()#
    col.out = which(names(data)==model[['response']])#
    for (i in 1:length(model[['model']])) {#
        m = predict(model[['model']][[i]], s=model[['s']][[i]], newx=data[,-col.out], type='coefficients')#
        test = abs(m@x[which(m@i==(which(m@Dimnames[[1]]==name.var)-1))])#
        if(name.var %in% m@Dimnames[[1]][m@i+1]) {#
            var = c(var, m@x[which(m@i==(which(m@Dimnames[[1]]==name.var)-1))])#
        } else {#
            var = c(var, 0)#
        }#
    }#
    df.plot = data.frame(output=var)#
    #Put the county names into a form that can be matched.#
    locs = unique(merge(model[['data']][,c('x','y','county','state')], model[['coords']]))#
#
    df.plot$county = tolower(as.character(locs$county))#
    df.plot$state = tolower(as.character(locs$state))#
    for (i in 1:dim(df.plot)[1]) {#
        county = gsub("['-. ]", '', df.plot$county[i])#
        df.plot$county[i] = paste(county, tolower(df.plot$state[i]), sep=',')#
    }    #
    #extract reference data#
    mapcounties <- map_data('county')#
    mapstates <- map_data('state')#
    #limit our view to the midwest:#
    midweststates = mapstates[tolower(mapstates$region) %in% tolower(df.plot$state),]#
    midwestcounties = mapcounties[tolower(mapcounties$region) %in% tolower(df.plot$state),]#
    #merge data with ggplot county coordinates#
    midwestcounties$county <- with(midwestcounties , paste(gsub("['-. ]", '', subregion), region, sep=","))#
    mergedata <- merge(midwestcounties, df.plot, by.x = "county", by.y = "county")#
    mergedata <- mergedata[order(mergedata$group, mergedata$order),]#
    #draw map#
    map <- ggplot(mergedata, aes(long,lat,group=group)) + geom_polygon(aes(fill=output))#
    if (mean(df.plot$output, na.rm=TRUE)<=0)        #
        map <- map + scale_fill_gradient(low='red', high='white', limits=range(df.plot$output, na.rm=TRUE), name='coef') + coord_map(project='globular')#
    else#
        map <- map + scale_fill_gradient(low='white', high='red', limits=range(df.plot$output, na.rm=TRUE), name='coef') + coord_map(project='globular')#
    map <- map + opts(panel.background=theme_rect(fill='green', colour='red'))#
    #add state borders#
    map <- map + geom_path(data=midweststates, colour='white', size=0.75)#
    #add county borders#
    map <- map + geom_path(data=midwestcounties, colour='white', size=0.5, alpha=0.1)#
    map + opts(title=paste("Coefficient of '", name.var, "' in a model for logitindpov", sep='')) #+ guides(fill=guide_legend(reverse=TRUE))#
}
gwglmnet.sel(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001))
library(glmnet)
gwglmnet.sel(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001))
landcover$APB
gwglmnet.sel(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001))
gwglmnet <- function(formula, data, coords, gweight, bw, D=NULL, verbose=FALSE, longlat=FALSE, adapt=FALSE, s, family, weights=NULL, nearest.neighbors=FALSE) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)    #
    #m <- match(c("formula", "data", "weights"), names(mf), 0)#
    m <- match(c("formula", "data"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))      #
    #weights <- as.vector(model.extract(mf, "weights"))    #
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    if (is.null(D)) {#
        #Get the matrix of distances#
        n = dim(coords)[1]#
        if (longlat) {#
            D = as.matrix(earth.dist(coords),n,n)#
        } else {#
            Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
        }#
    }    #
#
    #Get the weight matrix#
    if (!nearest.neighbors) {#
        weight.matrix = gweight(D, bw)#
    } else {#
        n = dim(D)[1]#
        bandwidths = sapply(1:n, function(x) {neighbor.weight(q=bw, D=D[x,], weight.function=gweight, verbose=verbose, tol=0.001)})#
        weight.matrix = as.matrix(rbind(sapply(1:n, function(k) {gweight(as.vector(D[k,]), as.numeric(bandwidths[1,k]))})),n,n)#
    }#
#
    if (!adapt) {#
        res = gwglmnet.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    else {#
        res = gwglmnet.adaptive.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    res[['data']] = data#
    res[['response']] = as.character(formula[[2]])#
    res#
}#
gwglmnet.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwglmnet.object = list()#
    cv.error = list()#
#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        prior.loow = prior.weights[-colocated]#
        reps = length(colocated)        #
        w <- prior.loow * loow#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        if (family=='binomial' && sum(yy) == nrow(yy)) {#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xx, y=cbind(1-yy, yy), weights=w, family=family, lambda=s)#
            predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), s=s, type='response')#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = NULL#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}#
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        m <- ncol(xx)#
        n <- nrow(xx)#
        one <- rep(1, n)#
        meanx <- drop(one %*% xx)/n#
        x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adapt.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
        beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
        adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
        adapt.scale[[i]] = adapt.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(adapt.weight[k])) {#
                xs[,k] = xs[,k] * adapt.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        coef.scale[[i]] = adapt.weight/normx#
        names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
#
        if (family=='binomial' && sum(yy) == nrow(yy)) {#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
gwglmnet.sel(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001))
gwglmnet <- function(formula, data, coords, gweight, bw, D=NULL, verbose=FALSE, longlat=FALSE, adapt=FALSE, s, family, weights=NULL, nearest.neighbors=FALSE) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)    #
    #m <- match(c("formula", "data", "weights"), names(mf), 0)#
    m <- match(c("formula", "data"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))      #
    #weights <- as.vector(model.extract(mf, "weights"))    #
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    if (is.null(D)) {#
        #Get the matrix of distances#
        n = dim(coords)[1]#
        if (longlat) {#
            D = as.matrix(earth.dist(coords),n,n)#
        } else {#
            Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
        }#
    }    #
#
    #Get the weight matrix#
    if (!nearest.neighbors) {#
        weight.matrix = gweight(D, bw)#
    } else {#
        n = dim(D)[1]#
        bandwidths = sapply(1:n, function(x) {neighbor.weight(q=bw, D=D[x,], weight.function=gweight, verbose=verbose, tol=0.001)})#
        weight.matrix = as.matrix(rbind(sapply(1:n, function(k) {gweight(as.vector(D[k,]), as.numeric(bandwidths[1,k]))})),n,n)#
    }#
#
    if (!adapt) {#
        res = gwglmnet.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    else {#
        res = gwglmnet.adaptive.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    res[['data']] = data#
    res[['response']] = as.character(formula[[2]])#
    res#
}#
gwglmnet.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwglmnet.object = list()#
    cv.error = list()#
#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        prior.loow = prior.weights[-colocated]#
        reps = length(colocated)        #
        w <- prior.loow * loow#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        if (family=='binomial' && (sum(yy)==nrow(yy) || sum(yy)==0)) {#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xx, y=cbind(1-yy, yy), weights=w, family=family, lambda=s)#
            predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), s=s, type='response')#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = NULL#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}#
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        m <- ncol(xx)#
        n <- nrow(xx)#
        one <- rep(1, n)#
        meanx <- drop(one %*% xx)/n#
        x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adapt.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
        beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
        adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
        adapt.scale[[i]] = adapt.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(adapt.weight[k])) {#
                xs[,k] = xs[,k] * adapt.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        coef.scale[[i]] = adapt.weight/normx#
        names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
#
        if (family=='binomial' && (sum(yy)==nrow(yy) || sum(yy)==0)) {#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
gwglmnet.sel(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001))
n = dim(landcover)[1]
coords=landcover[,c('X','Y')]
Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)
bisquare(D, 3230.86544512658)
w = bisquare(D, 3230.86544512658)
rowsum(w)
apply(w, 1, sum)
min(apply(w, 1, sum))
londcover(APB.87)
landcover(APB.87)
landcover$APB.87
w
apply(w, 1, function(x) {X*landcover$APB.87})
apply(w, 1, function(x) {x*landcover$APB.87})
apply(w, 1, function(x) {sum(x*landcover$APB.87)})
gwglmnet <- function(formula, data, coords, gweight, bw, D=NULL, verbose=FALSE, longlat=FALSE, adapt=FALSE, s, family, weights=NULL, nearest.neighbors=FALSE) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)    #
    #m <- match(c("formula", "data", "weights"), names(mf), 0)#
    m <- match(c("formula", "data"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))      #
    #weights <- as.vector(model.extract(mf, "weights"))    #
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    if (is.null(D)) {#
        #Get the matrix of distances#
        n = dim(coords)[1]#
        if (longlat) {#
            D = as.matrix(earth.dist(coords),n,n)#
        } else {#
            Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
        }#
    }    #
#
    #Get the weight matrix#
    if (!nearest.neighbors) {#
        weight.matrix = gweight(D, bw)#
    } else {#
        n = dim(D)[1]#
        bandwidths = sapply(1:n, function(x) {neighbor.weight(q=bw, D=D[x,], weight.function=gweight, verbose=verbose, tol=0.001)})#
        weight.matrix = as.matrix(rbind(sapply(1:n, function(k) {gweight(as.vector(D[k,]), as.numeric(bandwidths[1,k]))})),n,n)#
    }#
#
    if (!adapt) {#
        res = gwglmnet.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    else {#
        res = gwglmnet.adaptive.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    res[['data']] = data#
    res[['response']] = as.character(formula[[2]])#
    res#
}#
gwglmnet.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwglmnet.object = list()#
    cv.error = list()#
#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        prior.loow = prior.weights[-colocated]#
        reps = length(colocated)        #
        w <- prior.loow * loow#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        if (family=='binomial' && (sum(yy*w)==sum(w) || sum(yy*w)==0)) {#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xx, y=cbind(1-yy, yy), weights=w, family=family, lambda=s)#
            predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), s=s, type='response')#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = NULL#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}#
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        m <- ncol(xx)#
        n <- nrow(xx)#
        one <- rep(1, n)#
        meanx <- drop(one %*% xx)/n#
        x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adapt.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
        beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
        adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
        adapt.scale[[i]] = adapt.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(adapt.weight[k])) {#
                xs[,k] = xs[,k] * adapt.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        coef.scale[[i]] = adapt.weight/normx#
        names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
#
        if (family=='binomial' && (sum(yy*w)==nrow(yy*w) || sum(yy)==0)) {#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
gwglmnet(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001), bw=3230.9)
gwglmnet <- function(formula, data, coords, gweight, bw, D=NULL, verbose=FALSE, longlat=FALSE, adapt=FALSE, s, family, weights=NULL, nearest.neighbors=FALSE) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)    #
    #m <- match(c("formula", "data", "weights"), names(mf), 0)#
    m <- match(c("formula", "data"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))      #
    #weights <- as.vector(model.extract(mf, "weights"))    #
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    if (is.null(D)) {#
        #Get the matrix of distances#
        n = dim(coords)[1]#
        if (longlat) {#
            D = as.matrix(earth.dist(coords),n,n)#
        } else {#
            Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
        }#
    }    #
#
    #Get the weight matrix#
    if (!nearest.neighbors) {#
        weight.matrix = gweight(D, bw)#
    } else {#
        n = dim(D)[1]#
        bandwidths = sapply(1:n, function(x) {neighbor.weight(q=bw, D=D[x,], weight.function=gweight, verbose=verbose, tol=0.001)})#
        weight.matrix = as.matrix(rbind(sapply(1:n, function(k) {gweight(as.vector(D[k,]), as.numeric(bandwidths[1,k]))})),n,n)#
    }#
#
    if (!adapt) {#
        res = gwglmnet.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    else {#
        res = gwglmnet.adaptive.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    res[['data']] = data#
    res[['response']] = as.character(formula[[2]])#
    res#
}#
gwglmnet.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwglmnet.object = list()#
    cv.error = list()#
#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        prior.loow = prior.weights[-colocated]#
        reps = length(colocated)        #
        w <- prior.loow * loow#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        if (family=='binomial' && (sum(yy*w)==sum(w) || sum(yy*w)==0)) {#
            print(sum(yy*w))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            print(sum(yy*w))#
            model[[i]] = glmnet(x=xx, y=cbind(1-yy, yy), weights=w, family=family, lambda=s)#
            predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), s=s, type='response')#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = NULL#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}#
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        m <- ncol(xx)#
        n <- nrow(xx)#
        one <- rep(1, n)#
        meanx <- drop(one %*% xx)/n#
        x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
        normx <- sqrt(drop(one %*% (x.centered^2)))#
        adapt.normx[[i]] = normx#
        names(normx) <- NULL#
        xs = x.centered#
        for (k in 1:dim(x.centered)[2]) {#
            if (normx[k]!=0) {#
                xs[,k] = xs[,k] / normx[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                normx[k] = Inf #This should allow the lambda-finding step to work.#
            }#
        }#
        out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
        beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
        adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
        adapt.scale[[i]] = adapt.weight#
        for (k in 1:dim(x.centered)[2]) {#
            if (!is.na(adapt.weight[k])) {#
                xs[,k] = xs[,k] * adapt.weight[k]#
            } else {#
                xs[,k] = rep(0, dim(xs)[1])#
                adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
            }#
        }#
        #Use the lars algorithm to fit the model#
        coef.scale[[i]] = adapt.weight/normx#
        names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
#
        if (family=='binomial' && (sum(yy*w)==nrow(yy*w) || sum(yy)==0)) {#
            print(sum(yy*w))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            print(sum(yy*w))#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
gwglmnet(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001), bw=3230.9)
gwglmnet <- function(formula, data, coords, gweight, bw, D=NULL, verbose=FALSE, longlat=FALSE, adapt=FALSE, s, family, weights=NULL, nearest.neighbors=FALSE) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)    #
    #m <- match(c("formula", "data", "weights"), names(mf), 0)#
    m <- match(c("formula", "data"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))      #
    #weights <- as.vector(model.extract(mf, "weights"))    #
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    if (is.null(D)) {#
        #Get the matrix of distances#
        n = dim(coords)[1]#
        if (longlat) {#
            D = as.matrix(earth.dist(coords),n,n)#
        } else {#
            Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
        }#
    }    #
#
    #Get the weight matrix#
    if (!nearest.neighbors) {#
        weight.matrix = gweight(D, bw)#
    } else {#
        n = dim(D)[1]#
        bandwidths = sapply(1:n, function(x) {neighbor.weight(q=bw, D=D[x,], weight.function=gweight, verbose=verbose, tol=0.001)})#
        weight.matrix = as.matrix(rbind(sapply(1:n, function(k) {gweight(as.vector(D[k,]), as.numeric(bandwidths[1,k]))})),n,n)#
    }#
#
    if (!adapt) {#
        res = gwglmnet.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    else {#
        res = gwglmnet.adaptive.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    res[['data']] = data#
    res[['response']] = as.character(formula[[2]])#
    res#
}#
gwglmnet.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwglmnet.object = list()#
    cv.error = list()#
#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        prior.loow = prior.weights[-colocated]#
        reps = length(colocated)        #
        w <- prior.loow * loow#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        print(sum(yy*w))#
        if (family=='binomial' && (sum(yy*w)==sum(w) || sum(yy*w)==0)) {#
            print("Aborted")#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xx, y=cbind(1-yy, yy), weights=w, family=family, lambda=s)#
            predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), s=s, type='response')#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = NULL#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}#
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
#
        print(sum(yy*w))#
        if (family=='binomial' && (sum(yy*w)==nrow(yy*w) || sum(yy)==0)) {            #
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            m <- ncol(xx)#
            n <- nrow(xx)#
            one <- rep(1, n)#
            meanx <- drop(one %*% xx)/n#
            x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
            normx <- sqrt(drop(one %*% (x.centered^2)))#
            adapt.normx[[i]] = normx#
            names(normx) <- NULL#
            xs = x.centered#
            for (k in 1:dim(x.centered)[2]) {#
                if (normx[k]!=0) {#
                    xs[,k] = xs[,k] / normx[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    normx[k] = Inf #This should allow the lambda-finding step to work.#
                }#
            }#
            out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
            beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
            adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
            adapt.scale[[i]] = adapt.weight#
            for (k in 1:dim(x.centered)[2]) {#
                if (!is.na(adapt.weight[k])) {#
                    xs[,k] = xs[,k] * adapt.weight[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
                }#
            }#
            #Use the lars algorithm to fit the model#
            coef.scale[[i]] = adapt.weight/normx#
            names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
gwglmnet(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001), bw=3230.9)
gwglmnet <- function(formula, data, coords, gweight, bw, D=NULL, verbose=FALSE, longlat=FALSE, adapt=FALSE, s, family, weights=NULL, nearest.neighbors=FALSE) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)    #
    #m <- match(c("formula", "data", "weights"), names(mf), 0)#
    m <- match(c("formula", "data"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))      #
    #weights <- as.vector(model.extract(mf, "weights"))    #
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    if (is.null(D)) {#
        #Get the matrix of distances#
        n = dim(coords)[1]#
        if (longlat) {#
            D = as.matrix(earth.dist(coords),n,n)#
        } else {#
            Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
        }#
    }    #
#
    #Get the weight matrix#
    if (!nearest.neighbors) {#
        weight.matrix = gweight(D, bw)#
    } else {#
        n = dim(D)[1]#
        bandwidths = sapply(1:n, function(x) {neighbor.weight(q=bw, D=D[x,], weight.function=gweight, verbose=verbose, tol=0.001)})#
        weight.matrix = as.matrix(rbind(sapply(1:n, function(k) {gweight(as.vector(D[k,]), as.numeric(bandwidths[1,k]))})),n,n)#
    }#
#
    if (!adapt) {#
        res = gwglmnet.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    else {#
        res = gwglmnet.adaptive.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    res[['data']] = data#
    res[['response']] = as.character(formula[[2]])#
    res#
}#
gwglmnet.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwglmnet.object = list()#
    cv.error = list()#
#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        prior.loow = prior.weights[-colocated]#
        reps = length(colocated)        #
        w <- prior.loow * loow#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        print(sum(yy*w))#
        if (family=='binomial' && (sum(yy*w)==sum(w) || sum(yy*w)==0)) {#
            print("Aborted")#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xx, y=cbind(1-yy, yy), weights=w, family=family, lambda=s)#
            predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), s=s, type='response')#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = NULL#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}#
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
#
        print(sum(yy*w))#
        if (family=='binomial' && (sum(yy*w)==nrow(yy*w) || sum(yy)==0)) {            #
            print("abort")#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            m <- ncol(xx)#
            n <- nrow(xx)#
            one <- rep(1, n)#
            meanx <- drop(one %*% xx)/n#
            x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
            normx <- sqrt(drop(one %*% (x.centered^2)))#
            adapt.normx[[i]] = normx#
            names(normx) <- NULL#
            xs = x.centered#
            for (k in 1:dim(x.centered)[2]) {#
                if (normx[k]!=0) {#
                    xs[,k] = xs[,k] / normx[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    normx[k] = Inf #This should allow the lambda-finding step to work.#
                }#
            }#
            out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
            beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
            adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
            adapt.scale[[i]] = adapt.weight#
            for (k in 1:dim(x.centered)[2]) {#
                if (!is.na(adapt.weight[k])) {#
                    xs[,k] = xs[,k] * adapt.weight[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
                }#
            }#
            #Use the lars algorithm to fit the model#
            coef.scale[[i]] = adapt.weight/normx#
            names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
gwglmnet(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001), bw=3230.9)
gwglmnet <- function(formula, data, coords, gweight, bw, D=NULL, verbose=FALSE, longlat=FALSE, adapt=FALSE, s, family, weights=NULL, nearest.neighbors=FALSE) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)    #
    #m <- match(c("formula", "data", "weights"), names(mf), 0)#
    m <- match(c("formula", "data"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))      #
    #weights <- as.vector(model.extract(mf, "weights"))    #
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    if (is.null(D)) {#
        #Get the matrix of distances#
        n = dim(coords)[1]#
        if (longlat) {#
            D = as.matrix(earth.dist(coords),n,n)#
        } else {#
            Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
        }#
    }    #
#
    #Get the weight matrix#
    if (!nearest.neighbors) {#
        weight.matrix = gweight(D, bw)#
    } else {#
        n = dim(D)[1]#
        bandwidths = sapply(1:n, function(x) {neighbor.weight(q=bw, D=D[x,], weight.function=gweight, verbose=verbose, tol=0.001)})#
        weight.matrix = as.matrix(rbind(sapply(1:n, function(k) {gweight(as.vector(D[k,]), as.numeric(bandwidths[1,k]))})),n,n)#
    }#
#
    if (!adapt) {#
        res = gwglmnet.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    else {#
        res = gwglmnet.adaptive.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    res[['data']] = data#
    res[['response']] = as.character(formula[[2]])#
    res#
}#
gwglmnet.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwglmnet.object = list()#
    cv.error = list()#
#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        prior.loow = prior.weights[-colocated]#
        reps = length(colocated)        #
        w <- prior.loow * loow#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        print(sum(yy*w))#
        if (family=='binomial' && (sum(yy*w)==sum(w) || sum(yy*w)==0)) {#
            print("Aborted")#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xx, y=cbind(1-yy, yy), weights=w, family=family, lambda=s)#
            predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), s=s, type='response')#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = NULL#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}#
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
#
        print(i)#
        print(sum(yy*w))#
        if (family=='binomial' && (sum(yy*w)==nrow(yy*w) || sum(yy)==0)) {            #
            print("abort")#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            m <- ncol(xx)#
            n <- nrow(xx)#
            one <- rep(1, n)#
            meanx <- drop(one %*% xx)/n#
            x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
            normx <- sqrt(drop(one %*% (x.centered^2)))#
            adapt.normx[[i]] = normx#
            names(normx) <- NULL#
            xs = x.centered#
            for (k in 1:dim(x.centered)[2]) {#
                if (normx[k]!=0) {#
                    xs[,k] = xs[,k] / normx[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    normx[k] = Inf #This should allow the lambda-finding step to work.#
                }#
            }#
            out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
            beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
            adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
            adapt.scale[[i]] = adapt.weight#
            for (k in 1:dim(x.centered)[2]) {#
                if (!is.na(adapt.weight[k])) {#
                    xs[,k] = xs[,k] * adapt.weight[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
                }#
            }#
            #Use the lars algorithm to fit the model#
            coef.scale[[i]] = adapt.weight/normx#
            names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
gwglmnet(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001), bw=3230.9)
i=58
colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])
coords.unique = unique(coords)
colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])
loow = w[i,-colocated]
ww=w
w=loow
xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])
y = landcover$APB.87
yy = as.matrix(y[-colocated])
YY*w
yy*w
sum(yy*w)
family='binomial'
if (family=='binomial' && (sum(yy*w)==nrow(yy*w) || sum(yy)==0))
print(test)
test
if (sum(yy*w)==nrow(yy*w) || sum(yy)==0) {}
if (sum(yy*w)==nrow(yy*w) || sum(yy)==0) {
print("a")
}
if (sum(yy*w)==nrow(yy*w) | sum(yy)==0) {
print("a")
}
if (sum(yy*w)==nrow(yy*w) || sum(yy*w)==0) {
print("a")
}
gwglmnet <- function(formula, data, coords, gweight, bw, D=NULL, verbose=FALSE, longlat=FALSE, adapt=FALSE, s, family, weights=NULL, nearest.neighbors=FALSE) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)    #
    #m <- match(c("formula", "data", "weights"), names(mf), 0)#
    m <- match(c("formula", "data"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))      #
    #weights <- as.vector(model.extract(mf, "weights"))    #
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    if (is.null(D)) {#
        #Get the matrix of distances#
        n = dim(coords)[1]#
        if (longlat) {#
            D = as.matrix(earth.dist(coords),n,n)#
        } else {#
            Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
        }#
    }    #
#
    #Get the weight matrix#
    if (!nearest.neighbors) {#
        weight.matrix = gweight(D, bw)#
    } else {#
        n = dim(D)[1]#
        bandwidths = sapply(1:n, function(x) {neighbor.weight(q=bw, D=D[x,], weight.function=gweight, verbose=verbose, tol=0.001)})#
        weight.matrix = as.matrix(rbind(sapply(1:n, function(k) {gweight(as.vector(D[k,]), as.numeric(bandwidths[1,k]))})),n,n)#
    }#
#
    if (!adapt) {#
        res = gwglmnet.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    else {#
        res = gwglmnet.adaptive.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    res[['data']] = data#
    res[['response']] = as.character(formula[[2]])#
    res#
}#
gwglmnet.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwglmnet.object = list()#
    cv.error = list()#
#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        prior.loow = prior.weights[-colocated]#
        reps = length(colocated)        #
        w <- prior.loow * loow#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        print(sum(yy*w))#
        if (family=='binomial' && (sum(yy*w)==sum(w) || sum(yy*w)==0)) {#
            print("Aborted")#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xx, y=cbind(1-yy, yy), weights=w, family=family, lambda=s)#
            predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), s=s, type='response')#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = NULL#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}#
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
#
        print(i)#
        print(sum(yy*w))#
        if (family=='binomial' && (sum(yy*w)==nrow(yy*w) || sum(yy*w)==0)) {            #
            print("abort")#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            m <- ncol(xx)#
            n <- nrow(xx)#
            one <- rep(1, n)#
            meanx <- drop(one %*% xx)/n#
            x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
            normx <- sqrt(drop(one %*% (x.centered^2)))#
            adapt.normx[[i]] = normx#
            names(normx) <- NULL#
            xs = x.centered#
            for (k in 1:dim(x.centered)[2]) {#
                if (normx[k]!=0) {#
                    xs[,k] = xs[,k] / normx[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    normx[k] = Inf #This should allow the lambda-finding step to work.#
                }#
            }#
            out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
            beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
            adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
            adapt.scale[[i]] = adapt.weight#
            for (k in 1:dim(x.centered)[2]) {#
                if (!is.na(adapt.weight[k])) {#
                    xs[,k] = xs[,k] * adapt.weight[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
                }#
            }#
            #Use the lars algorithm to fit the model#
            coef.scale[[i]] = adapt.weight/normx#
            names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
gwglmnet(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001), bw=3230.9)
gwglmnet <- function(formula, data, coords, gweight, bw, D=NULL, verbose=FALSE, longlat=FALSE, adapt=FALSE, s, family, weights=NULL, nearest.neighbors=FALSE) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)    #
    #m <- match(c("formula", "data", "weights"), names(mf), 0)#
    m <- match(c("formula", "data"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))      #
    #weights <- as.vector(model.extract(mf, "weights"))    #
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    if (is.null(D)) {#
        #Get the matrix of distances#
        n = dim(coords)[1]#
        if (longlat) {#
            D = as.matrix(earth.dist(coords),n,n)#
        } else {#
            Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
        }#
    }    #
#
    #Get the weight matrix#
    if (!nearest.neighbors) {#
        weight.matrix = gweight(D, bw)#
    } else {#
        n = dim(D)[1]#
        bandwidths = sapply(1:n, function(x) {neighbor.weight(q=bw, D=D[x,], weight.function=gweight, verbose=verbose, tol=0.001)})#
        weight.matrix = as.matrix(rbind(sapply(1:n, function(k) {gweight(as.vector(D[k,]), as.numeric(bandwidths[1,k]))})),n,n)#
    }#
#
    if (!adapt) {#
        res = gwglmnet.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    else {#
        res = gwglmnet.adaptive.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    res[['data']] = data#
    res[['response']] = as.character(formula[[2]])#
    res#
}#
gwglmnet.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwglmnet.object = list()#
    cv.error = list()#
#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        prior.loow = prior.weights[-colocated]#
        reps = length(colocated)        #
        w <- prior.loow * loow#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        if (family=='binomial' && (sum(yy*w)==sum(w) || sum(yy*w)==0)) {#
            print("Aborted")#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xx, y=cbind(1-yy, yy), weights=w, family=family, lambda=s)#
            predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), s=s, type='response')#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = NULL#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}#
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
#
        if (family=='binomial' && (sum(yy*w)==nrow(yy*w) || sum(yy*w)==0)) {            #
            print("abort")#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            m <- ncol(xx)#
            n <- nrow(xx)#
            one <- rep(1, n)#
            meanx <- drop(one %*% xx)/n#
            x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
            normx <- sqrt(drop(one %*% (x.centered^2)))#
            adapt.normx[[i]] = normx#
            names(normx) <- NULL#
            xs = x.centered#
            for (k in 1:dim(x.centered)[2]) {#
                if (normx[k]!=0) {#
                    xs[,k] = xs[,k] / normx[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    normx[k] = Inf #This should allow the lambda-finding step to work.#
                }#
            }#
            out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
            beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
            adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
            adapt.scale[[i]] = adapt.weight#
            for (k in 1:dim(x.centered)[2]) {#
                if (!is.na(adapt.weight[k])) {#
                    xs[,k] = xs[,k] * adapt.weight[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
                }#
            }#
            #Use the lars algorithm to fit the model#
            coef.scale[[i]] = adapt.weight/normx#
            names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
gwglmnet.sel(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001))
gwglmnet <- function(formula, data, coords, gweight, bw, D=NULL, verbose=FALSE, longlat=FALSE, adapt=FALSE, s, family, weights=NULL, nearest.neighbors=FALSE) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)    #
    #m <- match(c("formula", "data", "weights"), names(mf), 0)#
    m <- match(c("formula", "data"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))      #
    #weights <- as.vector(model.extract(mf, "weights"))    #
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    if (is.null(D)) {#
        #Get the matrix of distances#
        n = dim(coords)[1]#
        if (longlat) {#
            D = as.matrix(earth.dist(coords),n,n)#
        } else {#
            Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
        }#
    }    #
#
    #Get the weight matrix#
    if (!nearest.neighbors) {#
        weight.matrix = gweight(D, bw)#
    } else {#
        n = dim(D)[1]#
        bandwidths = sapply(1:n, function(x) {neighbor.weight(q=bw, D=D[x,], weight.function=gweight, verbose=verbose, tol=0.001)})#
        weight.matrix = as.matrix(rbind(sapply(1:n, function(k) {gweight(as.vector(D[k,]), as.numeric(bandwidths[1,k]))})),n,n)#
    }#
#
    if (!adapt) {#
        res = gwglmnet.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    else {#
        res = gwglmnet.adaptive.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    res[['data']] = data#
    res[['response']] = as.character(formula[[2]])#
    res#
}#
gwglmnet.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwglmnet.object = list()#
    cv.error = list()#
#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        prior.loow = prior.weights[-colocated]#
        reps = length(colocated)        #
        w <- prior.loow * loow#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        if (family=='binomial' && (sum(yy*w)==sum(w) || sum(yy*w)==0)) {#
            cat(paste("Abort. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), sep=''))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xx, y=cbind(1-yy, yy), weights=w, family=family, lambda=s)#
            predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), s=s, type='response')#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = NULL#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}#
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
#
        if (family=='binomial' && (sum(yy*w)==sum(w) || sum(yy*w)==0)) {            #
            cat(paste("Abort. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), sep=''))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            m <- ncol(xx)#
            n <- nrow(xx)#
            one <- rep(1, n)#
            meanx <- drop(one %*% xx)/n#
            x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
            normx <- sqrt(drop(one %*% (x.centered^2)))#
            adapt.normx[[i]] = normx#
            names(normx) <- NULL#
            xs = x.centered#
            for (k in 1:dim(x.centered)[2]) {#
                if (normx[k]!=0) {#
                    xs[,k] = xs[,k] / normx[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    normx[k] = Inf #This should allow the lambda-finding step to work.#
                }#
            }#
            out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
            beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
            adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
            adapt.scale[[i]] = adapt.weight#
            for (k in 1:dim(x.centered)[2]) {#
                if (!is.na(adapt.weight[k])) {#
                    xs[,k] = xs[,k] * adapt.weight[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
                }#
            }#
            #Use the lars algorithm to fit the model#
            coef.scale[[i]] = adapt.weight/normx#
            names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
gwglmnet(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001), bw=3230.9)
gwglmnet <- function(formula, data, coords, gweight, bw, D=NULL, verbose=FALSE, longlat=FALSE, adapt=FALSE, s, family, weights=NULL, nearest.neighbors=FALSE) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)    #
    #m <- match(c("formula", "data", "weights"), names(mf), 0)#
    m <- match(c("formula", "data"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))      #
    #weights <- as.vector(model.extract(mf, "weights"))    #
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    if (is.null(D)) {#
        #Get the matrix of distances#
        n = dim(coords)[1]#
        if (longlat) {#
            D = as.matrix(earth.dist(coords),n,n)#
        } else {#
            Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
        }#
    }    #
#
    #Get the weight matrix#
    if (!nearest.neighbors) {#
        weight.matrix = gweight(D, bw)#
    } else {#
        n = dim(D)[1]#
        bandwidths = sapply(1:n, function(x) {neighbor.weight(q=bw, D=D[x,], weight.function=gweight, verbose=verbose, tol=0.001)})#
        weight.matrix = as.matrix(rbind(sapply(1:n, function(k) {gweight(as.vector(D[k,]), as.numeric(bandwidths[1,k]))})),n,n)#
    }#
#
    if (!adapt) {#
        res = gwglmnet.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    else {#
        res = gwglmnet.adaptive.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    res[['data']] = data#
    res[['response']] = as.character(formula[[2]])#
    res#
}#
gwglmnet.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwglmnet.object = list()#
    cv.error = list()#
#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        prior.loow = prior.weights[-colocated]#
        reps = length(colocated)        #
        w <- prior.loow * loow#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        if (family=='binomial' && (sum(yy*w)==sum(w) || sum(yy*w)==0)) {#
            cat(paste("Abort. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xx, y=cbind(1-yy, yy), weights=w, family=family, lambda=s)#
            predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), s=s, type='response')#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = NULL#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}#
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
#
        if (family=='binomial' && (sum(yy*w)==sum(w) || sum(yy*w)==0)) {            #
            cat(paste("Abort. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            m <- ncol(xx)#
            n <- nrow(xx)#
            one <- rep(1, n)#
            meanx <- drop(one %*% xx)/n#
            x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
            normx <- sqrt(drop(one %*% (x.centered^2)))#
            adapt.normx[[i]] = normx#
            names(normx) <- NULL#
            xs = x.centered#
            for (k in 1:dim(x.centered)[2]) {#
                if (normx[k]!=0) {#
                    xs[,k] = xs[,k] / normx[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    normx[k] = Inf #This should allow the lambda-finding step to work.#
                }#
            }#
            out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
            beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
            adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
            adapt.scale[[i]] = adapt.weight#
            for (k in 1:dim(x.centered)[2]) {#
                if (!is.na(adapt.weight[k])) {#
                    xs[,k] = xs[,k] * adapt.weight[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
                }#
            }#
            #Use the lars algorithm to fit the model#
            coef.scale[[i]] = adapt.weight/normx#
            names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
apply(w, 1, function(x) {sum(x*landcover$APB.87)})
apply(ww, 1, function(x) {sum(x*landcover$APB.87)})
apply(ww, 1, function(x) {sum(x*landcover$APB.87) - sum(x)})
range(apply(ww, 1, function(x) {sum(x*landcover$APB.87) - sum(x)}))
gwglmnet <- function(formula, data, coords, gweight, bw, D=NULL, verbose=FALSE, longlat=FALSE, adapt=FALSE, s, family, weights=NULL, nearest.neighbors=FALSE) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)    #
    #m <- match(c("formula", "data", "weights"), names(mf), 0)#
    m <- match(c("formula", "data"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))      #
    #weights <- as.vector(model.extract(mf, "weights"))    #
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    if (is.null(D)) {#
        #Get the matrix of distances#
        n = dim(coords)[1]#
        if (longlat) {#
            D = as.matrix(earth.dist(coords),n,n)#
        } else {#
            Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
        }#
    }    #
#
    #Get the weight matrix#
    if (!nearest.neighbors) {#
        weight.matrix = gweight(D, bw)#
    } else {#
        n = dim(D)[1]#
        bandwidths = sapply(1:n, function(x) {neighbor.weight(q=bw, D=D[x,], weight.function=gweight, verbose=verbose, tol=0.001)})#
        weight.matrix = as.matrix(rbind(sapply(1:n, function(k) {gweight(as.vector(D[k,]), as.numeric(bandwidths[1,k]))})),n,n)#
    }#
#
    if (!adapt) {#
        res = gwglmnet.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    else {#
        res = gwglmnet.adaptive.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    res[['data']] = data#
    res[['response']] = as.character(formula[[2]])#
    res#
}#
gwglmnet.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwglmnet.object = list()#
    cv.error = list()#
#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        prior.loow = prior.weights[-colocated]#
        reps = length(colocated)        #
        w <- prior.loow * loow#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        if (family=='binomial' && (sum(yy*w)==sum(w) || sum(yy*w)==0)) {#
            cat(paste("Abort. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xx, y=cbind(1-yy, yy), weights=w, family=family, lambda=s)#
            predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), s=s, type='response')#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = NULL#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}#
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
#
        if (family=='binomial' && (sum(yy*w)==sum(w) || sum(yy*w)==0)) {            #
            cat(paste("Abort. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            cat(paste("All go. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            m <- ncol(xx)#
            n <- nrow(xx)#
            one <- rep(1, n)#
            meanx <- drop(one %*% xx)/n#
            x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
            normx <- sqrt(drop(one %*% (x.centered^2)))#
            adapt.normx[[i]] = normx#
            names(normx) <- NULL#
            xs = x.centered#
            for (k in 1:dim(x.centered)[2]) {#
                if (normx[k]!=0) {#
                    xs[,k] = xs[,k] / normx[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    normx[k] = Inf #This should allow the lambda-finding step to work.#
                }#
            }#
            out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
            beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
            adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
            adapt.scale[[i]] = adapt.weight#
            for (k in 1:dim(x.centered)[2]) {#
                if (!is.na(adapt.weight[k])) {#
                    xs[,k] = xs[,k] * adapt.weight[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
                }#
            }#
            #Use the lars algorithm to fit the model#
            coef.scale[[i]] = adapt.weight/normx#
            names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
gwglmnet(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001), bw=3230.9)
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
#
        if (family=='binomial' && (sum(yy*w)-sum(w)<1e-5 || sum(yy*w)<1e-5)) {            #
            cat(paste("Abort. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            cat(paste("All go. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            m <- ncol(xx)#
            n <- nrow(xx)#
            one <- rep(1, n)#
            meanx <- drop(one %*% xx)/n#
            x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
            normx <- sqrt(drop(one %*% (x.centered^2)))#
            adapt.normx[[i]] = normx#
            names(normx) <- NULL#
            xs = x.centered#
            for (k in 1:dim(x.centered)[2]) {#
                if (normx[k]!=0) {#
                    xs[,k] = xs[,k] / normx[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    normx[k] = Inf #This should allow the lambda-finding step to work.#
                }#
            }#
            out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
            beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
            adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
            adapt.scale[[i]] = adapt.weight#
            for (k in 1:dim(x.centered)[2]) {#
                if (!is.na(adapt.weight[k])) {#
                    xs[,k] = xs[,k] * adapt.weight[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
                }#
            }#
            #Use the lars algorithm to fit the model#
            coef.scale[[i]] = adapt.weight/normx#
            names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
gwglmnet(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001), bw=3230.9)
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
#
        if (family=='binomial' && (abs(sum(yy*w)-sum(w))<1e-5 || sum(yy*w)<1e-5)) {            #
            cat(paste("Abort. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            cat(paste("All go. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            m <- ncol(xx)#
            n <- nrow(xx)#
            one <- rep(1, n)#
            meanx <- drop(one %*% xx)/n#
            x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
            normx <- sqrt(drop(one %*% (x.centered^2)))#
            adapt.normx[[i]] = normx#
            names(normx) <- NULL#
            xs = x.centered#
            for (k in 1:dim(x.centered)[2]) {#
                if (normx[k]!=0) {#
                    xs[,k] = xs[,k] / normx[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    normx[k] = Inf #This should allow the lambda-finding step to work.#
                }#
            }#
            out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
            beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
            adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
            adapt.scale[[i]] = adapt.weight#
            for (k in 1:dim(x.centered)[2]) {#
                if (!is.na(adapt.weight[k])) {#
                    xs[,k] = xs[,k] * adapt.weight[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
                }#
            }#
            #Use the lars algorithm to fit the model#
            coef.scale[[i]] = adapt.weight/normx#
            names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
gwglmnet(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001), bw=3230.9)
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
#
        if (family=='binomial' && (abs(sum(yy*w)-sum(w))<1e-4 || sum(yy*w)<1e-4)) {            #
            cat(paste("Abort. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            cat(paste("All go. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            m <- ncol(xx)#
            n <- nrow(xx)#
            one <- rep(1, n)#
            meanx <- drop(one %*% xx)/n#
            x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
            normx <- sqrt(drop(one %*% (x.centered^2)))#
            adapt.normx[[i]] = normx#
            names(normx) <- NULL#
            xs = x.centered#
            for (k in 1:dim(x.centered)[2]) {#
                if (normx[k]!=0) {#
                    xs[,k] = xs[,k] / normx[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    normx[k] = Inf #This should allow the lambda-finding step to work.#
                }#
            }#
            out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
            beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
            adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
            adapt.scale[[i]] = adapt.weight#
            for (k in 1:dim(x.centered)[2]) {#
                if (!is.na(adapt.weight[k])) {#
                    xs[,k] = xs[,k] * adapt.weight[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
                }#
            }#
            #Use the lars algorithm to fit the model#
            coef.scale[[i]] = adapt.weight/normx#
            names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
m=gwglmnet(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001), bw=3230.9)
gwglmnet <- function(formula, data, coords, gweight, bw, D=NULL, verbose=FALSE, longlat=FALSE, adapt=FALSE, s, family, weights=NULL, nearest.neighbors=FALSE) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)    #
    #m <- match(c("formula", "data", "weights"), names(mf), 0)#
    m <- match(c("formula", "data"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))      #
    #weights <- as.vector(model.extract(mf, "weights"))    #
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    if (is.null(D)) {#
        #Get the matrix of distances#
        n = dim(coords)[1]#
        if (longlat) {#
            D = as.matrix(earth.dist(coords),n,n)#
        } else {#
            Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
        }#
    }    #
#
    #Get the weight matrix#
    if (!nearest.neighbors) {#
        weight.matrix = gweight(D, bw)#
    } else {#
        n = dim(D)[1]#
        bandwidths = sapply(1:n, function(x) {neighbor.weight(q=bw, D=D[x,], weight.function=gweight, verbose=verbose, tol=0.001)})#
        weight.matrix = as.matrix(rbind(sapply(1:n, function(k) {gweight(as.vector(D[k,]), as.numeric(bandwidths[1,k]))})),n,n)#
    }#
#
    if (!adapt) {#
        res = gwglmnet.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    else {#
        res = gwglmnet.adaptive.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    res[['data']] = data#
    res[['response']] = as.character(formula[[2]])#
    res#
}#
gwglmnet.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwglmnet.object = list()#
    cv.error = list()#
#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        prior.loow = prior.weights[-colocated]#
        reps = length(colocated)        #
        w <- prior.loow * loow#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        if (family=='binomial' && (abs(sum(yy*w)-sum(w))<1e-4 || sum(yy*w)<1e-4)) {#
            cat(paste("Abort. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xx, y=cbind(1-yy, yy), weights=w, family=family, lambda=s)#
            predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), s=s, type='response')#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = NULL#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}#
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
#
        if (family=='binomial' && (abs(sum(yy*w)-sum(w))<1e-4 || sum(yy*w)<1e-4)) {            #
            cat(paste("Abort. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            cat(paste("All go. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            m <- ncol(xx)#
            n <- nrow(xx)#
            one <- rep(1, n)#
            meanx <- drop(one %*% xx)/n#
            x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
            normx <- sqrt(drop(one %*% (x.centered^2)))#
            adapt.normx[[i]] = normx#
            names(normx) <- NULL#
            xs = x.centered#
            for (k in 1:dim(x.centered)[2]) {#
                if (normx[k]!=0) {#
                    xs[,k] = xs[,k] / normx[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    normx[k] = Inf #This should allow the lambda-finding step to work.#
                }#
            }#
            out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
            beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
            adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
            adapt.scale[[i]] = adapt.weight#
            for (k in 1:dim(x.centered)[2]) {#
                if (!is.na(adapt.weight[k])) {#
                    xs[,k] = xs[,k] * adapt.weight[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
                }#
            }#
            #Use the lars algorithm to fit the model#
            coef.scale[[i]] = adapt.weight/normx#
            names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
bandwidth=gwglmnet.sel(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001))
gwglmnet <- function(formula, data, coords, gweight, bw, D=NULL, verbose=FALSE, longlat=FALSE, adapt=FALSE, s, family, weights=NULL, nearest.neighbors=FALSE) {#
    if (!is.logical(adapt)) #
        stop("adapt must be logical")#
    if (is(data, "Spatial")) {#
        if (!missing(coords)) #
            warning("data is Spatial* object, ignoring coords argument")#
        coords <- coordinates(data)#
        if ((is.null(longlat) || !is.logical(longlat)) && !is.na(is.projected(data)) && #
            !is.projected(data)) {#
            longlat <- TRUE#
        }#
        else longlat <- FALSE#
        data <- as(data, "data.frame")#
    }#
    if (is.null(longlat) || !is.logical(longlat)) #
        longlat <- FALSE#
    if (missing(coords)) #
        stop("Observation coordinates have to be given")#
    mf <- match.call(expand.dots = FALSE)    #
    #m <- match(c("formula", "data", "weights"), names(mf), 0)#
    m <- match(c("formula", "data"), names(mf), 0)#
    mf <- mf[c(1, m)]#
    mf$drop.unused.levels <- TRUE#
    mf[[1]] <- as.name("model.frame")#
    mf <- eval(mf, parent.frame())#
    mt <- attr(mf, "terms")#
    dp.n <- length(model.extract(mf, "response"))      #
    #weights <- as.vector(model.extract(mf, "weights"))    #
    if (!is.null(weights) && !is.numeric(weights)) #
        stop("'weights' must be a numeric vector")#
    if (is.null(weights)) #
        weights <- rep(as.numeric(1), dp.n)#
    if (any(is.na(weights))) #
        stop("NAs in weights")#
    if (any(weights < 0)) #
        stop("negative weights")#
    y <- model.extract(mf, "response")#
    x <- model.matrix(mt, mf)#
#
    if (is.null(D)) {#
        #Get the matrix of distances#
        n = dim(coords)[1]#
        if (longlat) {#
            D = as.matrix(earth.dist(coords),n,n)#
        } else {#
            Xmat = matrix(rep(coords[,1], times=n), n, n)#
            Ymat = matrix(rep(coords[,2], times=n), n, n)#
            D = sqrt((Xmat-t(Xmat))**2 + (Ymat-t(Ymat))**2)#
        }#
    }    #
#
    #Get the weight matrix#
    if (!nearest.neighbors) {#
        weight.matrix = gweight(D, bw)#
    } else {#
        n = dim(D)[1]#
        bandwidths = sapply(1:n, function(x) {neighbor.weight(q=bw, D=D[x,], weight.function=gweight, verbose=verbose, tol=0.001)})#
        weight.matrix = as.matrix(rbind(sapply(1:n, function(k) {gweight(as.vector(D[k,]), as.numeric(bandwidths[1,k]))})),n,n)#
    }#
#
    if (!adapt) {#
        res = gwglmnet.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    else {#
        res = gwglmnet.adaptive.fit(x, y, coords, weight.matrix, s, verbose, family, weights)#
    }#
    res[['data']] = data#
    res[['response']] = as.character(formula[[2]])#
    res#
}#
gwglmnet.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (non-adaptive algorithm)#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    gwglmnet.object = list()#
    cv.error = list()#
#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        prior.loow = prior.weights[-colocated]#
        reps = length(colocated)        #
        w <- prior.loow * loow#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }   #
        reps = length(colocated)        #
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
        if (family=='binomial' && (abs(sum(yy*w)-sum(w))<1e-4 || sum(yy*w)<1e-4)) {#
            cat(paste("Abort. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            model[[i]] = glmnet(x=xx, y=cbind(1-yy, yy), weights=w, family=family, lambda=s)#
            predictions = predict(model[[i]], newx=matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), s=s, type='response')#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = NULL#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}#
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
#
        if (family=='binomial' && (abs(sum(yy*w)-sum(w))<1e-4 || sum(yy*w)<1e-4)) {            #
            cat(paste("Abort. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            m <- ncol(xx)#
            n <- nrow(xx)#
            one <- rep(1, n)#
            meanx <- drop(one %*% xx)/n#
            x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
            normx <- sqrt(drop(one %*% (x.centered^2)))#
            adapt.normx[[i]] = normx#
            names(normx) <- NULL#
            xs = x.centered#
            for (k in 1:dim(x.centered)[2]) {#
                if (normx[k]!=0) {#
                    xs[,k] = xs[,k] / normx[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    normx[k] = Inf #This should allow the lambda-finding step to work.#
                }#
            }#
            out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
            beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
            adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
            adapt.scale[[i]] = adapt.weight#
            for (k in 1:dim(x.centered)[2]) {#
                if (!is.na(adapt.weight[k])) {#
                    xs[,k] = xs[,k] * adapt.weight[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
                }#
            }#
            #Use the lars algorithm to fit the model#
            coef.scale[[i]] = adapt.weight/normx#
            names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
bandwidth=gwglmnet.sel(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001))
bandwidth=gwglmnet.sel(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=FALSE, gweight=bisquare, s=c(0,5,0.0001))
m$cv.error
m$s
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
#
        if (family=='binomial' && (abs(sum(yy*w)-sum(w))<1e-4 || sum(yy*w)<1e-4)) {            #
            cat(paste("Abort. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            m <- ncol(xx)#
            n <- nrow(xx)#
            one <- rep(1, n)#
            meanx <- drop(one %*% xx)/n#
            x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
            normx <- sqrt(drop(one %*% (x.centered^2)))#
            adapt.normx[[i]] = normx#
            names(normx) <- NULL#
            xs = x.centered#
            for (k in 1:dim(x.centered)[2]) {#
                if (normx[k]!=0) {#
                    xs[,k] = xs[,k] / normx[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    normx[k] = Inf #This should allow the lambda-finding step to work.#
                }#
            }#
            out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
            beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
            adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
            adapt.scale[[i]] = adapt.weight#
            for (k in 1:dim(x.centered)[2]) {#
                if (!is.na(adapt.weight[k])) {#
                    xs[,k] = xs[,k] * adapt.weight[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
                }#
            }#
            #Use the lars algorithm to fit the model#
            coef.scale[[i]] = adapt.weight/normx#
            names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = rowSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
m=gwglmnet(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001), bw=3230.9)
m$cv.error
gwglmnet.adaptive.fit = function(x, y, coords, weight.matrix, s, verbose, family, prior.weights) {#
#Fit the gwglmnet model (adaptive algorithm)#
    gwglmnet.object = list()#
    coords.unique = unique(coords)#
    model = list()#
    s.optimal = vector()#
    adapt.normx = list()#
    adapt.scale = list()#
    cv.error = list()#
    coef.scale = list()#
    for(i in 1:dim(coords.unique)[1]) {#
        colocated = which(coords[,1]==coords.unique[i,1] & coords[,2]==coords.unique[i,2])#
        loow = weight.matrix[i,-colocated]#
        if (sum(loow)==0) { return(list(cv.error = Inf)) }      #
#
        prior.loow = prior.weights[-colocated]      #
        reps = length(colocated)        #
        w <- prior.loow * loow#
        xx = as.matrix(x[-colocated,])#
        yy = as.matrix(y[-colocated])#
#
        if (family=='binomial' && (abs(sum(yy*w)-sum(w))<1e-4 || sum(yy*w)<1e-4)) {            #
            cat(paste("Abort. i=", i, ", weighted sum=", sum(yy*w), ", sum of weights=", sum(w), "\n", sep=''))#
            model[[i]] = NULL#
            cv.error[[i]] = 0#
            s.optimal = c(s.optimal, max(s))#
        } else {#
            m <- ncol(xx)#
            n <- nrow(xx)#
            one <- rep(1, n)#
            meanx <- drop(one %*% xx)/n#
            x.centered <- scale(xx, meanx, FALSE)         # first subtracts mean#
            normx <- sqrt(drop(one %*% (x.centered^2)))#
            adapt.normx[[i]] = normx#
            names(normx) <- NULL#
            xs = x.centered#
            for (k in 1:dim(x.centered)[2]) {#
                if (normx[k]!=0) {#
                    xs[,k] = xs[,k] / normx[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    normx[k] = Inf #This should allow the lambda-finding step to work.#
                }#
            }#
            out.glm = glm(yy~xs, family=family, weights=w)  # mle fit on standardized#
            beta.glm = out.glm$coeff[2:(m+1)]                    # mle except for intercept#
            adapt.weight = abs(beta.glm)                        # weights for adaptive lasso#
            adapt.scale[[i]] = adapt.weight#
            for (k in 1:dim(x.centered)[2]) {#
                if (!is.na(adapt.weight[k])) {#
                    xs[,k] = xs[,k] * adapt.weight[k]#
                } else {#
                    xs[,k] = rep(0, dim(xs)[1])#
                    adapt.weight[k] = 0 #This should allow the lambda-finding step to work.#
                }#
            }#
            #Use the lars algorithm to fit the model#
            coef.scale[[i]] = adapt.weight/normx#
            names(coef.scale[[i]]) = sapply(strsplit(names(coef.scale[[i]]), 'xs'), function(x) {x[2]})#
            model[[i]] = glmnet(x=xs, y=cbind(1-yy, yy), lambda=s, family=family, weights=w)#
            predictions = predict(model[[i]], newx=scale(matrix(x[colocated,], nrow=reps, ncol=dim(xx)[2]), center=meanx, scale=normx/adapt.weight), type='response', s=s)#
            cv.error[[i]] = colSums(abs(matrix(predictions - matrix(y[colocated], nrow=reps, ncol=length(s)), nrow=reps, ncol=length(s))))#
            s.optimal = c(s.optimal, s[which.min(cv.error[[i]])])#
        }#
#
        if (verbose) { cat(paste(i, "\n", sep='')) }#
    }#
    gwglmnet.object[['coef.scale']] = coef.scale#
    gwglmnet.object[['model']] = model#
    gwglmnet.object[['s']] = s.optimal#
    gwglmnet.object[['mode']] = mode#
    gwglmnet.object[['coords']] = coords.unique#
    gwglmnet.object[['cv.error']] = cv.error#
    gwglmnet.object[['s.range']] = s#
    class(gwglmnet.object) = 'gwglmnet.object'#
    return(gwglmnet.object)#
}
m=gwglmnet(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=c(0,5,0.0001), bw=10000)
m$cv.error
warnings()
m=gwglmnet(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=TRUE, gweight=bisquare, s=seq(0,5,0.0001), bw=10000)
bandwidth=gwglmnet.sel(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=FALSE, gweight=bisquare, s=seq(0,5,0.0005))
bandwidth=gwglmnet.sel(APB.87~Cover1930 + Cover1857, data=landcover, family='binomial', coords=landcover[,c('X','Y')], adapt=FALSE, gweight=bisquare, s=seq(0,5,1))
str(m)
m$model[[1]]
str(m$model[[1]])
AIC(m$model[[1]])
m$model[[1]]$dev
m
m$model
str(m$model[[1]])
names(m$model[[1]])
?glmnet
str(m$model[[2]])
str(m$model[[3]])
library(lars)
?lars
?predict.lars
